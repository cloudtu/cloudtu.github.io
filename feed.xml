<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>老涂的咁仔店</title>
    <link>http://cloudtu.github.io</link>
    <atom:link href="http://cloudtu.github.io/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <description>老涂的咁仔店</description>
    <language>zh-TW</language>
    <pubDate>Thu, 3 Sep 2015 23:44:13 +0800</pubDate>
    <lastBuildDate>Thu, 3 Sep 2015 23:44:13 +0800</lastBuildDate>

    <item>
      <title>gradle learning path</title>
      <link>http://cloudtu.github.io/blog/2015/09/gradle-learning-path.html</link>
      <pubDate>Thu, 3 Sep 2015 22:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/09/gradle-learning-path.html</guid>
      <description>&lt;p&gt;我用 gradle 當 build tool 已經好一陣子，通常照著網路上的 gradle 範例去修改就可以讓它滿足我的需求，真是超方便。可是對於 gradle script 為啥長這個樣子? 它的運作原理為何? 我一直搞不懂所以然。這次花了些時間終於了解它的基礎原理到底是怎麼回事。下述是我學習 gradle 基礎原理的 learning path，請照條列順序依序閱讀，看完後就可以對 gradle 知其然又知其所以然!&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;想要 gradle 快速上手? 看 popcorn 的 &quot;Gradle起步走(&lt;a href=&quot;http://www.slideshare.net/popcornylu/gradle-cli-application&quot;&gt;投影片&lt;/a&gt;、&lt;a href=&quot;https://www.youtube.com/watch?v=rWXspaS-pHI&quot;&gt;影片&lt;/a&gt;)&quot; 就對啦&lt;/li&gt;
  &lt;li&gt;對 gradle 有點 fu 之後就可以把 &lt;a href=&quot;https://www.manning.com/books/gradle-in-action&quot;&gt;grdle in action&lt;/a&gt; 這本書拿來看了。整本書分成三個 part，只要看 part1, part2 就夠了，part3 是比較進階的應用，未來有需要的話再來看&lt;/li&gt;
  &lt;li&gt;grdle in action 看完後可能會覺的對 gradle script 的 groovy 語法理解太少，這時必需看一些 groovy 語法說明，所以下面這些資料都看一看吧。
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.manning.com/books/gradle-in-action&quot;&gt;grdle in action&lt;/a&gt; 的 Appendix B 章節&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.vogella.com/tutorials/Groovy/article.html&quot;&gt;Groovy with Eclipse - Tutorial&lt;/a&gt; 的項次 1 ~ 14 內容&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/JustinSDK/groovy-gradle?ref=http://www.codedata.com.tw/java/groovy-gradle-abc/&quot;&gt;淺談 Groovy 與 Gradle&lt;/a&gt;。這份 slide 看完後對 groovy 的 closure 會有很清楚的理解，也終於知道 gradle script 語法用了大量的 closure&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;前面的都看完後就可以開始看下列講 gradle 運作原理的文章，看完後就會知道 gradle script 語法其實是 groovy closure 與 delegate pattern 的組合
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-1-ant/&quot;&gt;【認識 Gradle】（1）講古的時間 Apache Ant&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-2-maven/&quot;&gt;【認識 Gradle】（2）講古的時間 Apache Maven&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-3-getting-started/&quot;&gt;【認識 Gradle】（3）Gradle 起手式&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-4-gradle-script/&quot;&gt;【認識 Gradle】（4）看懂 Gradle Script&lt;/a&gt;。這份文件解釋了 gradle script 語法跟 groovy closure 、delegate pattern 的關聯性&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-3-gradle-task-abc/&quot;&gt;【認識 Gradle】（5）Gradle Task 觀念導讀&lt;/a&gt;。這份文件解釋了 gradle task 裡的 action closure、configure closure 是怎麼一回事。&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-4-java-project-build-script-customization/&quot;&gt;【認識 Gradle】（6）Java 專案與 Build Script 客製化&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-7-java-project-dependencies/&quot;&gt;認識 Gradle】（7）Java 專案相依管理&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-8-reuse-logic/&quot;&gt;【認識 Gradle】（8）邏輯重用&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;前述資料都看完後對於 gradle 官網的 &lt;a href=&quot;https://docs.gradle.org/current/userguide/userguide.html&quot;&gt;user guide &lt;/a&gt;、&lt;a href=&quot;https://docs.gradle.org/current/dsl/&quot;&gt;DSL Reference&lt;/a&gt;、&lt;a href=&quot;https://docs.gradle.org/current/javadoc/&quot;&gt;javadoc&lt;/a&gt; 應該就都看的懂，而不會在查閱時有摸不著頭緒的感覺了&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>

    <item>
      <title>java 8 lambda resource</title>
      <link>http://cloudtu.github.io/blog/2015/08/java-8-lambda-resource.html</link>
      <pubDate>Thu, 27 Aug 2015 15:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/08/java-8-lambda-resource.html</guid>
      <description>&lt;p&gt;java 8 lambda 功能已經出來一年多，相關討論與資源也很多。不過這玩意兒如果太久沒用的話，總是把學到的又還回去。為了想複習時可以快速找到相關資源，還是把這些資訊筆記下來卡實在。以下是相關明細，有興趣的可以照條列順序依序閱讀。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;java 8 new api
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://ingramchen.io/blog/2014/04/java-8-new-api-tips.html&quot;&gt;Java 8 New API Tips&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;java 8 lambda
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/JustinSDK/12-lambda&quot;&gt;Java SE 8 技術手冊第 12 章 - Lambda&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/jdk8-functional-api/&quot;&gt;【演講稿】解析 JDK8 Functional API&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;monad design pattern
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/social-coding/java8-patterns/&quot;&gt;【演講稿】Java 8 Patterns&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://ingramchen.io/blog/2014/11/monad-design-pattern-in-java.html&quot;&gt;Monad Design Pattern in Java&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>

    <item>
      <title>利用 jbake 從 blogger 搬家到 github</title>
      <link>http://cloudtu.github.io/blog/2015/08/migrate-from-blogger-to-jbake.html</link>
      <pubDate>Tue, 18 Aug 2015 18:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/08/migrate-from-blogger-to-jbake.html</guid>
      <description>&lt;p&gt;打算搬離 &lt;a href=&quot;http://blogger.com&quot;&gt;blogger&lt;/a&gt; 的念頭很早就有了，只是一直沒有行動。主要原因還是打包整個站台的文章、圖片太麻煩，所以就一直沒動手。二週前開始有了段長時間的空檔，所以下定決心告別 blogger，自己蓋個新 blog 站台。&lt;/p&gt;&lt;h2&gt;為何搬離 blogger&lt;/h2&gt;&lt;p&gt;沒事 blogger 用的好好的為何會想搬家呢? 原因大略是下述儿點&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;不易撰寫技術文章。blogger 上面寫一般生活記事很容易，但是寫程式開發技術文就不是這麼回事了，要讓美美的程式碼秀出正常樣子實在太累人。&lt;/li&gt;
  &lt;li&gt;發佈文章前的文章檢視功能跑起來超慢。這可能跟我在 blogger 上插了很多外掛模組有關，但是這些模組我都會用到呀不能拿掉，所以這問題無解 囧rz&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;選擇新家&lt;/h2&gt;&lt;p&gt;既然要搬家了，那新家要怎麼選呢? 我決定 &lt;code&gt;自己的 blog 自己蓋&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;ingram 的 &lt;a href=&quot;http://ingramchen.io/blog/2014/01/move-to-new-home-again.html&quot;&gt;新年搬新家- Jbake&lt;/a&gt; 裡提到 &lt;code&gt;任何 Hosting Service 最終都會消失&lt;/code&gt; 是非常中肯的見解。雖然不見得一定會消失，但是未來的事實在太難說。現在寫 blog 早就不潮了，但是寫了十多年累積的 400 多篇文章說什麼也不能隨著搬家歸零重來。為了避免未來一而再再而三的搬家，還是自己蓋 blog 吧!&lt;/p&gt;&lt;h2&gt;新 blog 怎麼搭建?&lt;/h2&gt;&lt;p&gt;既然要自己土砲了，那當然是找目前市面上 &lt;code&gt;static site generator&lt;/code&gt; 產品有哪些。 &lt;a href=&quot;https://www.staticgen.com/&quot;&gt;StaticGen&lt;/a&gt; 上看到的統計報表裡，最熱門的產品是 &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt;，不過我是 java guy 所以我選 &lt;a href=&quot;http://jbake.org&quot;&gt;jbake&lt;/a&gt; 這個 java solution。&lt;/p&gt;&lt;p&gt;下列儿項 jbake 產品特性是我選它的原因&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;完整的&lt;a href=&quot;http://www.jbake.org/docs/2.4.0/&quot;&gt;說明書&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;多人維護的&lt;a href=&quot;https://github.com/jbake-org/jbake&quot;&gt;專案&lt;/a&gt;，不用擔心突然被放生。&lt;/li&gt;
  &lt;li&gt;blog 文章支援 &lt;code&gt;markdown&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt; 格式。html 格式就不用說了，算是舊時代的遺物，一定會支援。寫新文章的話，如果不是文章格式很複雜，我是一定會選擇 markdown 格式，可以省時又省力。&lt;/li&gt;
  &lt;li&gt;內建 &lt;code&gt;jetty&lt;/code&gt;，文章寫完後可以馬上在 local 跑起來看看結果正不正確，不需丟到 remote 才能進行驗証&lt;/li&gt;
  &lt;li&gt;文章裡貼的程式碼可以用 &lt;code&gt;pretty print&lt;/code&gt; 風格來呈現。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;jbake 快速上手&lt;/h2&gt;&lt;p&gt;下載 &lt;a href=&quot;http://www.jbake.org/download.html&quot;&gt;jbake&lt;/a&gt; 進行安裝。目前 v2.4.0 最新版有個&lt;a href=&quot;https://github.com/jbake-org/jbake/issues/226&quot;&gt;嚴重的 bug&lt;/a&gt;，每次 site gen 時一定會全部資料重建，沒辦法進行 incremental render，建議安裝 v2.3.2 版。&lt;/p&gt;&lt;p&gt;jbake v2.3.2 常用指令沒儿個，搞懂它吧!&lt;/p&gt;
&lt;!--?prettify?--&gt;
&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;# init jbake project
jbake -i
jbake -i &amp;lt;freemarker|groovy|thymeleaf&amp;gt;

# site gen
jbake -b
jbake -b &amp;lt;source&amp;gt; &amp;lt;output&amp;gt;

# start local server
jbake -s
jbake -s &amp;lt;directory&amp;gt;

# site gen &amp;amp; start local server
jbake -b -s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;http://www.jbake.org/docs/2.4.0/&quot;&gt;官方文件&lt;/a&gt;不長而且很完整，建議看過一遍。&lt;/p&gt;&lt;h2&gt;jbake.properties 設定檔說明&lt;/h2&gt;&lt;p&gt;其中比較需要特別說明的是 &lt;code&gt;db.store=local&lt;/code&gt;，設成這值代表每次 jbake 只會針對異動(新增或修改)的文章進行 site gen，不會全部的文章都進行 site gen，這是一個很有用的功能!&lt;/p&gt;
&lt;!--?prettify?--&gt;
&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;# defines the host URL for the site
site.host={my_blog_site_url}

# render index file?
render.index=true
# render archive file?
render.archive=true
# render feed file?
render.feed=true
# render tag files?
render.tags=true
# render sitemap.xml file?
render.sitemap=true

# filename of index template file
template.index.file=index.thyme
# filename of archive template file
template.archive.file=archive.thyme
# filename of tag template file
template.tag.file=tags.thyme
# filename of sitemap template file
template.sitemap.file=sitemap.thyme
# filename of post template file
template.post.file=post.thyme
# filename of page template file
template.page.file=page.thyme
# filename of feed template file
template.feed.file=feed.thyme

# default date format used in content files
date.format=yyyy-MM-dd

# database store (local, memory)
# This option defines whether the content store built while parsing your content files is persisted to disk or not.When it is persisted to disk the next time you perform a bake only those content files that have changed will be rendered speeding up the process. When it is not persisted to disk, i.e. kept in memory, a full bake of all content is performed every time.
db.store=local
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;撰寫 markdown 文件的注意事項&lt;/h2&gt;&lt;p&gt;文章如果出現 &lt;code&gt;包了太多層的條列式項目&lt;/code&gt; 可能會導致 site gen 後的 html 出現排版亂掉的問題，撰寫文章時要迴避這問題。&lt;/p&gt;&lt;h2&gt;markdown 文件如何插入圖片?&lt;/h2&gt;&lt;p&gt;只是單純的文章插入圖片可以直接用 markdown 語法&lt;/p&gt;
&lt;!--?prettify?--&gt;
&lt;pre&gt;&lt;code&gt;![imageName](imageFileUrl)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果要有 &lt;code&gt;點擊縮圖時開啟原始大圖&lt;/code&gt; 效果，必需用 html 語法&lt;/p&gt;
&lt;!--?prettify?--&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;a href=&amp;quot;/img/{myImage.jpg}&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;/img/{myImage.jpg}&amp;quot; width=&amp;quot;{width}&amp;quot; /&amp;gt;
&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;markdown 文件如何插入程式碼?&lt;/h2&gt;&lt;p&gt;可以用 markdown 或 html 語法，個人推薦用 markdown 語法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# markdown 格式
&amp;lt;!--?prettify linenums=true?--&amp;gt;
```java
public class CloudTu {
  public static void main(String[] args) {
    System.out.print(&amp;quot;hello world!&amp;quot;);
  }
}
```
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;# html 格式
&amp;lt;pre class=&amp;quot;prettyprint linenums&amp;quot;&amp;gt;
public class CloudTu {
  public static void main(String[] args) {
    System.out.print(&amp;quot;hello world!&amp;quot;);
  }
}
&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;site gen 結果像下面這樣，程式碼帶有行號而且是 pretty print 風格&lt;/p&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class CloudTu {
  public static void main(String[] args) {
    System.out.print(&amp;quot;hello world!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果不想帶行號的話則是把 &lt;code&gt;linenums&lt;/code&gt; 拿掉&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# markdown 格式
&amp;lt;!--?prettify?--&amp;gt;
my code...etc
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;# html 格式
&amp;lt;pre class=&amp;quot;prettyprint&amp;quot;&amp;gt;
    my code...etc
&amp;lt;pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;新 blog 要放在哪?&lt;/h2&gt;&lt;p&gt;任何可以放 static site 的雲端空間都可以當存放站台，我自己的選擇是放在 github。原因的話有二個&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;static site 放 github &lt;strike&gt;正潮&lt;/strike&gt;不用錢&lt;/li&gt;
  &lt;li&gt;github 的網路頻寬夠大，連過去速度夠快&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在 github 上建立 static site 的&lt;a href=&quot;https://pages.github.com/&quot;&gt;方法&lt;/a&gt;很簡單，分成二種方式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;第一種是在 github 上建立 &lt;code&gt;{myAccount}.github.io&lt;/code&gt; 的 repository，接著把 static site 推上去，然後連到 &lt;code&gt;http://{myAccount}.github.io&lt;/code&gt; 就可以看到建立的站台&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;第二種則是在 github 現有的 &lt;code&gt;{myProject}&lt;/code&gt; repository 建立 &lt;code&gt;gh-pages&lt;/code&gt; branch，接著把 static site 推上去，然後連到 &lt;code&gt;http://{myAccount}.github.io/{myProject}&lt;/code&gt; 就可以看到建立的站台&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;舊資料要怎麼搬過去?&lt;/h2&gt;&lt;p&gt;搬舊資料沒啥現成工具可用，只好自己寫工具。我利用 &lt;a href=&quot;http://jsoup.org/&quot;&gt;jsoup&lt;/a&gt;, &lt;a href=&quot;https://github.com/rometools/rome&quot;&gt;rome&lt;/a&gt; lib 寫了 &lt;a href=&quot;https://github.com/cloudtu/blogger-to-jbake&quot;&gt;blogger-to-jbake&lt;br/&gt;&lt;/a&gt; 這個專門從 blogger 搬家到 jbake 的搬遷工具。它可以把放在 blogger 裡的個人文章、圖片全部匯出至本地端，並且轉成 jbake 可以匯入的檔案格式。&lt;/p&gt;&lt;h2&gt;後記&lt;/h2&gt;&lt;p&gt;其實 blog 搬家很辛苦，自建 static blog site 就更辛苦了，但是相對的獲益也非常巨大。什麼都自己來代表什麼都掌控在手中，未來如果發生任何狀況都可以自己應付，也不會遇到 vendor 倒了就全部資料人間蒸發的鳥事。記得以前無名小站倒了時網路上哀聲遍野，未來收掉的 blog service 只會更多不會更少，長遠考量下還是自己的 blog 自己蓋比較實際呀~~~&lt;/p&gt;</description>
    </item>

    <item>
      <title>java library for github api 心得筆記</title>
      <link>http://cloudtu.github.io/blog/2015/07/java-library-for-github-api.html</link>
      <pubDate>Fri, 3 Jul 2015 13:34:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/07/java-library-for-github-api.html</guid>
      <description>
這陣子用 java 去呼叫 github restful api 之後有些心得，將它做個簡單記錄
&lt;br&gt;
&lt;ul&gt;
 &lt;li&gt;github api v3 說明文件在&lt;a href=&quot;https://developer.github.com/v3/&quot; target=&quot;_blank&quot;&gt;這裡&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;github 推薦的 java library 有&lt;a href=&quot;https://developer.github.com/libraries/&quot; target=&quot;_blank&quot;&gt;下列三個&lt;/a&gt;&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;&lt;a href=&quot;https://github.com/eclipse/egit-github/tree/master/org.eclipse.egit.github.core&quot; target=&quot;_blank&quot;&gt;egit-github&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;https://github.com/kohsuke/github-api&quot; target=&quot;_blank&quot;&gt;kohsuke-github-api&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;https://github.com/jcabi/jcabi-github&quot; target=&quot;_blank&quot;&gt;jcabi-github&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;java library 對 github api v3 支援度&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;kohsuke-github-api &amp;gt; jcabi-github &amp;gt; egit-github&lt;/li&gt;
   &lt;li&gt;kohsuke-github-api 實作最完整&lt;/li&gt;
   &lt;li&gt;jcabi-github 缺少很多實作&lt;/li&gt;
   &lt;li&gt;egit-github 的目標是 100% 支援 github api v3，可是 source code 裡反而還存留一堆呼叫 github legacy api 的 code&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;java library 操作便捷性&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt; jcabi-github &amp;gt; kohsuke-github-api &amp;gt; egit-github&lt;/li&gt;
   &lt;li&gt;kohsuke-github-api 與 jcabi-github 在操作上比 egit-github 好很多，egit-github 這方面顯的過時&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;java library 說明文件完整度&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;三者都很爛，沒啥文件說明。要查怎麼使用要去看 source code 裡 junit test 相關 class&lt;/li&gt;
   &lt;li&gt;因為 egit-github 出來時間最早，所以 &lt;a href=&quot;http://stackoverflow.com/&quot; target=&quot;_blank&quot;&gt;stackoverflow&lt;/a&gt; 裡比較能找到 egit-github 相關問題的解答&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;總結&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;以現況而言，個人推薦使用 kohsuke-github-api。它對 github api v3 支援最完整，在 libray 操作上也蠻直覺的&lt;/li&gt;
   &lt;li&gt;如果不介意 library 是否用到 github api v3，而是要找白老鼠最多的 library，那選 egit-github 就對了。它最早出來，所以功能最完整，白老鼠最多&lt;/li&gt;
   &lt;li&gt;從設計角度來看，jcabi-github 設計最好。但是因為它太年輕，欠缺很多功能&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;https://developer.github.com/v3/search/&quot; target=&quot;_blank&quot;&gt;github search api&lt;/a&gt; 有 bug，我遇過查詢條件正確，但是查詢結果是錯誤的狀況。如果用 java library 去呼叫 github api 卻發現結果總是錯的，這時除了要懷疑 library 本身有 bug 之外，最好要用 restful client 去驗証 github api 是不是一開始就回傳錯誤資料 &lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>

    <item>
      <title>用 https 連線到 github 進行 push(或 pull) 時，略過每次都要打帳密的動作</title>
      <link>http://cloudtu.github.io/blog/2015/02/https-github-push-pull.html</link>
      <pubDate>Thu, 26 Feb 2015 16:57:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/02/https-github-push-pull.html</guid>
      <description>
當 local repository 用 https 連線至 github 進行 push(或 pull) 時，總是都要打一次帳號與密碼。頻繁進行 push(或 pull) 時，打帳密的動作就變的很惱人。雖然說用 ssh 連線就可免掉這問題，不過在使用 https 的前題下，這問題也是有解法。
&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 
&lt;br&gt;首先，先確定 git 版本大於等於 1.7.9。如果是 windows 使用者，請先安裝 TortoiseGit(版本必需大於等於 1.8.1.2)。
&lt;br&gt;
&lt;br&gt;以下範例用 TortoiseGit 進行操作
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;確認 &quot;Credential helper&quot; 選到 &quot;wincred - this repository only&quot;。&lt;br&gt;&lt;a href=&quot;/img/2015/02/201502261657_1.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;/img/2015/02/201502261657_1.png&quot; height=&quot;183&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;進行修改後的第一次 push(或 pull)，這時會出現輸入帳密的指示，照著指示輸入完成。以後進行 push(或 pull) 時不會再問你帳密了。&lt;/li&gt;
 &lt;li&gt;開啟 &quot;我的電腦&quot;，輸入 &quot;控制台\使用者帳戶和家庭安全\認證管理員&quot;，這時會發現多一組 github 專用的憑証。以後你若改過 github 上的密碼，記的要來這裡修改憑証內的資料，不然在你執行 push(或 pull) 時會發生無法登入 github 的狀況。&lt;br&gt;&lt;a href=&quot;/img/2015/02/201502261657_2.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;/img/2015/02/201502261657_2.png&quot; height=&quot;332&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;網路上面相關參考資料如下，linux、mac 使用者可參考這些資料來處理上述文章所提的問題。 
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/a/5343146/779564&quot; target=&quot;_blank&quot;&gt;Is there a way to skip password typing when using https:// github&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/a/15351702/779564&quot; target=&quot;_blank&quot;&gt;TortoiseGit save user authentication / credentials&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/a/15382950/779564&quot; target=&quot;_blank&quot;&gt;remove credentials from git&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>

    <item>
      <title>如何備份 github 各別 project 所有 branch 到本地端，並將該專案搬移至 bitbucket</title>
      <link>http://cloudtu.github.io/blog/2015/02/github-project-branch-bitbucket.html</link>
      <pubDate>Thu, 26 Feb 2015 14:34:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/02/github-project-branch-bitbucket.html</guid>
      <description>
執行 &quot;git clone&quot; 無法將 github 各別 project 的所有 remote branch 都在 local repository 產生一份，只會在 local 產生 master branch。這時如果要將 local repository push 到(或說是搬到) new remote repository 會發生很大的問題。當你在 local repository 執行完 &quot;git push --all&quot; 後會發現 remote repository 只存在 master branch，其它 branch 不會出現在裡面。
&lt;br&gt;
&lt;br&gt;當然!你可以在執行完 &quot;git clone&quot; 後，接著執行 &quot;git checkout&quot; 將 remote branch 在 local repository 裡手動一個個建出來。不過這種傻事還是少幹的好，如果 remote branch 有好儿十個，手工建立對應的 local branch 可能會讓你哭爹喴娘。這時當然要用有效率的招式才行!!!
&lt;br&gt;
&lt;br&gt;先寫出備份 github project 專用的備份 script。我把它命名為 github_project_backup.sh
&lt;br&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;#github_project_backup.sh&lt;br&gt;#!/bin/sh&lt;br&gt;&lt;br&gt;#執行前要先修改這裡，設定你的 github id&lt;br&gt;github_user_id=my_github_id&lt;br&gt;&lt;br&gt;#執行前要先修改這裡，設定你的 github password&lt;br&gt;github_user_pwd=my_github_pwd&lt;br&gt;&lt;br&gt;#執行這個 bash 時，在 console 要輸入的 github project name&lt;br&gt;read -p &quot;input the name of github project : &quot; github_project_name&lt;br&gt;&lt;br&gt;#在 local 端產生 bare repository，並將 remote 端的每個 branch 都在 local 端產生一份&lt;br&gt;#&lt;br&gt;# --mirror 參數的官方說明如下&lt;br&gt;# Set up a mirror of the source repository. This implies --bare. Compared to --bare, --mirror not only &lt;br&gt;# maps local branches of the source to local branches of the target, it maps all refs (including &lt;br&gt;# remote-tracking branches, notes etc.) and sets up a refspec configuration such that all these refs &lt;br&gt;# are overwritten by a git remote update in the target repository.&lt;br&gt;#&lt;br&gt;git clone --mirror https://${github_user_id}:${github_user_pwd}@github.com/${github_user_id}/${github_project_name}.git&lt;br&gt;&lt;br&gt;cd ${github_project_name}.git&lt;br&gt;&lt;br&gt;#因為 remote repository 在你備份到 local 端之後可能會刪除，所以先把 remote 來源刪掉&lt;br&gt;git remote rm origin&lt;br&gt;&lt;br&gt;cd ..&lt;br&gt;&lt;/pre&gt;進行備份，流程像下述這樣
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;remote repository 有二個 branch、二個 tag&lt;br&gt;&lt;a href=&quot;/img/2015/02/201502261434_1.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;/img/2015/02/201502261434_1.png&quot; height=&quot;218&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;輸入 github 裡的 project name&lt;br&gt;&lt;a href=&quot;/img/2015/02/201502261434_2.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;/img/2015/02/201502261434_2.png&quot; height=&quot;157&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;github_project_backup.bash 執行完畢後，產生 local bare repository，而且裡面有二個 local branch、二個 local tag&lt;br&gt;&lt;a href=&quot;/img/2015/02/201502261434_3.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;/img/2015/02/201502261434_3.png&quot; height=&quot;400&quot; width=&quot;377&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;如果只打算把 github 的 project 在刪除前先備份到本地端後再刪除，到這步驟就算完成了。之後可以視需求再把備分下來的 local bare repository 進行 zip 或是 tgz 後丟到雲端(e.g. AWS S3,dropbox...etc)進行封存。
&lt;br&gt;
&lt;br&gt;如果是打算把 local repository push 到(或說是搬到) new remote repository，接下來要執行下列指令。
&lt;br&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;cd /path/to/my_local_repository&lt;br&gt;git remote add origin https://my_new_remote_repository&lt;br&gt;git push -u origin --all #pushes up the repo and its refs for the first time &lt;br&gt;git push -u origin --tags #pushes up any tags&lt;br&gt;&lt;/pre&gt;接續的搬移流程像下述這樣
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;new remote repository 指到 bitbucket&lt;br&gt;&lt;a href=&quot;/img/2015/02/201502261434_4.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;/img/2015/02/201502261434_4.png&quot; height=&quot;246&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;搬完後 bitbucket 裡的 remote repository 有二個 branch、二個 tag，跟當初放在 github 裡的一樣&lt;br&gt;&lt;a href=&quot;/img/2015/02/201502261434_5.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;/img/2015/02/201502261434_5.png&quot; height=&quot;153&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;至此就完成了從 github 搬到 bitbucket 的動作。
&lt;br&gt;
&lt;br&gt;你說何時有機會用到這篇文章的招式?如果你在 github 上面開了太多 private repository，超過單一付費帳號許可的最大上限(目前 github 最多只能開 50 個 private repository)，這招就用的上了...XDDD
</description>
    </item>

    <item>
      <title>OAuth2 心得筆記</title>
      <link>http://cloudtu.github.io/blog/2014/12/oauth2.html</link>
      <pubDate>Sun, 7 Dec 2014 20:07:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2014/12/oauth2.html</guid>
      <description>
這陣子因為工作上需要，必需了解 OAuth2 原理。在網路上查了一陣子後發現下面這份解說詳盡的投影片，有興趣的人可以參考一下...:)
&lt;br&gt;
&lt;br&gt;簡單易懂的 OAuth 2.0 (
&lt;a href=&quot;https://speakerdeck.com/chitsaou/jian-dan-yi-dong-de-oauth-2-dot-0&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;) (
&lt;a href=&quot;https://www.youtube.com/watch?v=tMG-kl_uohY&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;) 
&lt;br&gt;
&lt;br&gt;我沒有實作 OAuth2 的需求，但是有使用 OAuth2 的需求，必需對它裡面的認証、授權機制有通盤了解。投影片裡跟 OAuth2 認証、授權相關的資料節錄如下，並做摘要說明。
&lt;br&gt;
&lt;br&gt;======================================================================
&lt;br&gt;OAuth2 裡的 Role
&lt;br&gt;
&lt;br&gt;
&lt;a href=&quot;/img/2014/12/201412072007_1.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;/img/2014/12/201412072007_1.png&quot; height=&quot;218&quot; width=&quot;400&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;ul&gt;
 &lt;li&gt;Authorization Server&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;「Authorization Server」發出去的授權碼有二種，分別是「Grant Code」、「Token」&lt;/li&gt;
   &lt;li&gt;&amp;nbsp;「Resource Owner」同意「Client」存取「Resource Owner」的資料時，「Authorization Server」發「Grant Code」給「Client」&lt;/li&gt;
   &lt;li&gt;「Client」可以拿「Grant Code」跟「Authorization Server」換「Token」 &lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;Resource Server&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;「Resource Server」的存取認証是認「Token」不是認「Grant Code」&lt;/li&gt;
   &lt;li&gt;用「Token」跟「Resource Server」進行認証，認証成功後可以存取「Resource Owner」的資料 &lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;======================================================================
&lt;br&gt;OAuth2 授權流程
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;Authorization Code Grant Flow&lt;br&gt;&lt;a href=&quot;/img/2014/12/201412072007_2.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;/img/2014/12/201412072007_2.png&quot; height=&quot;208&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;br&gt;先跟「Authorization Server」要「Grant Code」，接著再用「Grant Code」去跟「Authorization Server」換「Token」&lt;/li&gt;
 &lt;li&gt;Implicit Grant Flow&lt;br&gt;&lt;a href=&quot;/img/2014/12/201412072007_3.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;/img/2014/12/201412072007_3.png&quot; height=&quot;277&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;br&gt;直接跟「Authorization Server」要「Token」，沒有「Grant Code」換「Token」的步驟&lt;/li&gt;
 &lt;li&gt;Resource Owner Password Credentials Grant Flow&lt;br&gt;&lt;a href=&quot;/img/2014/12/201412072007_4.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;/img/2014/12/201412072007_4.png&quot; height=&quot;233&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;br&gt;拿「Resource Owner」的 username、password 去跟「Authorization Server」要「Token」&lt;/li&gt;
 &lt;li&gt;Client Credentials Grant Flow &lt;br&gt;&lt;a href=&quot;/img/2014/12/201412072007_5.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;/img/2014/12/201412072007_5.png&quot; height=&quot;195&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;br&gt;「Authorization Server」不需經由認証就直接給「Token」&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>

    <item>
      <title>Cassandra Summit 2014 心得筆記</title>
      <link>http://cloudtu.github.io/blog/2014/10/cassandra-summit-2014.html</link>
      <pubDate>Wed, 1 Oct 2014 20:43:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2014/10/cassandra-summit-2014.html</guid>
      <description>
Datastax 把前陣子辦的 Cassandra Summit 2014 
&lt;a href=&quot;http://www.slideshare.net/planetcassandra/tag/cassandra-summit-2014&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;、
&lt;a href=&quot;http://www.youtube.com/playlist?list=PLqcm6qE9lgKJkxYZUOIykswDndrOItnn2&quot; target=&quot;_blank&quot;&gt;視訊影片&lt;/a&gt;公開出來了，把這堆資料大略看完後針對比較重要的儿份摘要如下 ... :) 
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;C* 2.1 新功能簡介&lt;br&gt; Real Data Models of Silicon Valley(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-real-data-models-of-silicon-valley&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=XGrJLZcRhAw&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)&lt;br&gt; &lt;/li&gt;
 &lt;li&gt;C* 2.1 的設定檔多了哪些重要參數&lt;br&gt; Lesser Known Features of Cassandra 2.1(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-lesser-known-features-of-cassandra-21&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=ppZfB2tCrEs&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)&lt;br&gt; &lt;/li&gt;
 &lt;li&gt;CQL3 在 C* 2.1 &amp;amp; 2.0 的語法為何? CQL3 查詢顯示結果跟實際的 ColumFamily 是怎麼對照?&lt;br&gt; CQL Under the Hood(&lt;a href=&quot;http://www.slideshare.net/rastrick/cql-under-the-hood-39023557&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?list=PLqcm6qE9lgKJkxYZUOIykswDndrOItnn2&amp;amp;v=CY5-bWpqAVA&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)&lt;br&gt; Understanding CQL3 Inside and Out(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-understanding-cql3-inside-and-out&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=XoUqfq54xuA&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)&lt;br&gt; &lt;/li&gt;
 &lt;li&gt;扮演 admin 角色負責管理維運&lt;br&gt; Monitor Everything!(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-monitor-everything&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=RhUoQPHNA1Y&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)，裡面有提到 nodetool 監控指令參數(page 27~69)，JVM GC log 參數設定(page 74~78)&lt;br&gt; &lt;/li&gt;
 &lt;li&gt;校能調教&lt;br&gt; Performance Tuning Cassandra in AWS(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-39501315&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=Qfzg7gcSK-g&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)&lt;br&gt; &lt;/li&gt;
 &lt;li&gt;Spark 與 C* 整合應用現況&lt;br&gt; Apache Spark - The SDK for All Big Data Platforms(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-apache-spark-the-sdk-for-all-big-data-platforms&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=Ot-nrOaJHLE&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)&lt;br&gt; &lt;/li&gt;
 &lt;li&gt;一些大公司在使用 C* 後分享的經驗談
  &lt;strike&gt;
   (血淚控訴)
  &lt;/strike&gt;&lt;br&gt; Apache Cassandra Best Practices at Ebay(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-39677149&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=gn4MDRmrfKo&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)，從 page 7 開始是經驗談&lt;br&gt; Launching PlayStation 4 with Apache Cassandra(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-launching-playstation-4-with-apache-cassandra&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=FwMWvhyEgmg&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)，從 page 36 開始是經驗談&lt;br&gt; Cassandra at Instagram 2014(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-cassandra-at-instagram-2014&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=_gc94ITUitY&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)，從 page 55 開始是經驗談 &lt;br&gt; Interactive OLAP Queries using Apache Cassandra and Spark(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-interactive-olap-queries-using-apache-cassandra-and-spark&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=zke8mp-kMMo&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)，講 Cassandra 與 Spark 整合使用的經驗&lt;br&gt; &lt;/li&gt;
&lt;/ol&gt;針對 C* 2.1 在 CQL 語法上提供的新功能，我個人不建議使用，因為有下述問題存在。這部份也提供給大家參考一下 
&lt;br&gt;
&lt;ul&gt;
 &lt;li&gt;UDT(User Defined Types) 功能還不成熟，未來的版本可能變動很大?&lt;/li&gt;
 &lt;li&gt;雖然改善了 counter 效能，不過我猜想它可能又無法向下相容舊版? 還是不要用counter 型別為妙&lt;/li&gt;
 &lt;li&gt;在 C* 2.1 有些語法宣告要加 frozen 這關鍵字，可是未來 C* 3.x 會把這關鍵字拿掉，未來版本八成無法向下相容這個宣告。為了個人身心健康，有這類宣告的功能就別用了吧&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>

    <item>
      <title>雲端 IaaS 主機建立 cassandra node 的注意事項</title>
      <link>http://cloudtu.github.io/blog/2014/09/iaas-cassandra-node.html</link>
      <pubDate>Tue, 23 Sep 2014 16:38:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2014/09/iaas-cassandra-node.html</guid>
      <description>
要在雲端 IaaS 主機建立 cassandra node，cassandra 設定檔裡跟 ip 有關的參數設定要特別留心，不然在 node 建完後會啟動失敗。這篇設定在&amp;nbsp; cassandra 1.x、2.x 都適用，有需要的可以參考一下...:)
&lt;br&gt;
&lt;br&gt;假設我在 AWS 建了一台 EC2，並且將它綁定 EIP(Elastic IP)，EC2 的 ip 資訊如下
&lt;br&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;private ip : 172.30.45.70&lt;br&gt;public ip : 50.190.20.220&lt;br&gt;&lt;/pre&gt;目前的 cassandra ring(cluster) 分佈在多個 AWS region，seed node 的 public ip 是 60.190.20.210。我要將該台 EC2 加入其中，相關注意事項如下 
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;cassandra.yaml&lt;br&gt;設定值要長像這樣，相關原因在官方文件有&lt;a href=&quot;http://www.datastax.com/documentation/cassandra/2.1/cassandra/architecture/architectureSnitchEC2MultiRegion_c.html?scroll=concept_ds_gck_hrf_fk__other-settings&quot; target=&quot;_blank&quot;&gt;說明&lt;/a&gt;&lt;br&gt;&lt;pre class=&quot;prettyprint&quot;&gt;endpoint_snitch: EC2MultiRegionSnitch&lt;br&gt;listen_address : ec2_private_ip&lt;br&gt;rpc_address : ec2_private_ip&lt;br&gt;broadcast_address : ec2_public_ip&lt;br&gt;seeds : seed_public_ip&lt;br&gt;&lt;/pre&gt;以目前的例子來說則是設成 &lt;pre class=&quot;prettyprint&quot;&gt;endpoint_snitch: EC2MultiRegionSnitch&lt;br&gt;listen_address : 172.30.45.70&lt;br&gt;rpc_address : 172.30.45.70&lt;br&gt;broadcast_address : 50.190.20.220&lt;br&gt;seeds : 60.190.20.210&lt;br&gt;&lt;/pre&gt;&lt;/li&gt;
 &lt;li&gt;cassandra-env.sh&lt;br&gt;增加下面這行跟 JMX 有關的設定。為何要加這行? 這是為了防止&amp;nbsp; nodetool 指令執行時出現 &quot;Connection has timed out&quot; 異常。這問題在 &lt;a href=&quot;http://stackoverflow.com/questions/15299302/cassandra-nodetool-connection-timed-out&quot; target=&quot;_blank&quot;&gt;stackoverflow &lt;/a&gt;有被討論跟解釋過。&lt;br&gt;&lt;pre class=&quot;prettyprint&quot;&gt;JVM_OPTS=&quot;$JVM_OPTS -Djava.rmi.server.hostname=127.0.0.1&quot;&lt;br&gt;&lt;/pre&gt;&lt;/li&gt;
 &lt;li&gt;EC2 的 firewall 把該開的 port 都打開(從 EC2 &amp;gt; Security Group &amp;gt; Inbound 設定裡改)，一般來說是開啟下面儿個 &lt;pre class=&quot;prettyprint&quot;&gt;storage_port : 7000&lt;br&gt;jmx_port : 7199&lt;br&gt;native_transport_port : 9042&lt;br&gt;rpc_port : 9160&lt;br&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;雖然這裡是用 EC2 當例子，不過只要是 IaaS 設定上應該都與此相似。比較大的差異在 cassandra.yaml 裡的 
&lt;a href=&quot;http://www.datastax.com/documentation/cassandra/2.1/cassandra/architecture/architectureSnitchesAbout_c.html&quot; target=&quot;_blank&quot;&gt;endpoint_snitch&lt;/a&gt; 設定，EC2 用 
&lt;a href=&quot;http://www.datastax.com/documentation/cassandra/2.1/cassandra/architecture/architectureSnitchEC2MultiRegion_c.html&quot; target=&quot;_blank&quot;&gt;EC2MultiRegionSnitch&lt;/a&gt;，GCE(GoogleComputerEngine) 用 
&lt;a href=&quot;http://www.datastax.com/documentation/cassandra/2.1/cassandra/architecture/architectureSnitchGoogle.html&quot; target=&quot;_blank&quot;&gt;GoogleCloudSnitch&lt;/a&gt;，混用 IaaS 跟一般傳統實體主機可以用 
&lt;a href=&quot;http://www.datastax.com/documentation/cassandra/2.1/cassandra/architecture/architectureSnitchGossipPF_c.html&quot; target=&quot;_blank&quot;&gt;GossipingPropertyFileSnitch&lt;/a&gt;。
&lt;br&gt;
&lt;br&gt;至於 ip 設定部份，其實只有一個重點&quot;機器內部內網溝通走 private ip，但是走到外網進行 broadcast 時要走 public ip&quot;。會這樣做的理由也很直覺，因為 public ip 是經由雲端服務綁定(e.g. AWS EIP)，VM 本身根本不知道自己有 public ip 這回事。
</description>
    </item>

    <item>
      <title>Cassandra 出現 HintsColumnFamily 異常巨大的解決辦法</title>
      <link>http://cloudtu.github.io/blog/2014/05/cassandra-hintscolumnfamily.html</link>
      <pubDate>Wed, 14 May 2014 15:47:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2014/05/cassandra-hintscolumnfamily.html</guid>
      <description>
這陣子在 Cassandra 的使用上遇到個很麻煩的怪事，那就是 ring 上某個 node 發生HintsColumnFamily 異常巨大的情況。執行下述指令後
&lt;br&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;ls -lh {cassandra_data_folder}/system/HintsColumnFamily*&lt;br&gt;&lt;/pre&gt;我發現 HintsColumnFamily 吃掉了 10儿G 的 HD，出問題的 node 跑起來跟快掛掉沒兩樣，實在是災難一場。
&lt;br&gt;
&lt;br&gt;要如何解決這場災難，可以參考下列資料
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;coordinator node 負擔是否過重?資料寫入動作不要集中單一 coordinator node ，要分散到多個 node &lt;/li&gt;
 &lt;li&gt;coordinator node 在跟 ring 裡其它 node 進行通訊(cassandra gossiping)時，是否通訊不良?在 coordinator node 執行下述指令，看看發生 &#39;Timed out replaying hint&#39; 訊息的是哪儿個 node，想辦法改善這些 node 的網路品質&lt;br&gt;&lt;pre class=&quot;prettyprint&quot;&gt;cat {cassandra_root_folder}/system.log | grep &#39;Timed out replaying hint&#39; | less&lt;br&gt;&lt;/pre&gt;&lt;/li&gt;
 &lt;li&gt;因為 HintsColumnFamily 過於巨大，要等裡面的資料慢慢被消化完是無意義的。最有效率的解決辦法是直接刪除 HintsColumnFamily 檔案，把 hinted handoff 資料全部放生，然後再到各個發生 &#39;Timed out replaying hint&#39; 的 node 執行 repair 動作。處理步驟如下&lt;br&gt;
  &lt;ol&gt;
   &lt;li&gt;連線到 coordinator node &lt;/li&gt;
   &lt;li&gt;shutdown cassandra &lt;pre class=&quot;prettyprint&quot;&gt;nodetool -h coordinator_node disablegossip&lt;br&gt;nodetool -h coordinator_node disablethrift&lt;br&gt;nodetool -h coordinator_node drain&lt;br&gt;kill -9 {cassandra_service_pid}&lt;br&gt;&lt;/pre&gt;&lt;/li&gt;
   &lt;li&gt;&lt;pre class=&quot;prettyprint&quot;&gt;rm -rf {cassandra_data_folder}/system/HintsColumnFamily*&lt;br&gt;&lt;/pre&gt;&lt;/li&gt;
   &lt;li&gt;start cassandra&lt;/li&gt;
   &lt;li&gt;連線到發生 &#39;Timed out replaying hint&#39; 的那儿個node，各別都執行下述指令，修復資料不一致的儿個 columnfamily&lt;br&gt;&lt;pre class=&quot;prettyprint&quot;&gt;nodetool -h hint_fail_node repair {repaired_keyspace} {repaired_columnfamily} -pr&lt;br&gt;&lt;/pre&gt;&lt;/li&gt;
   &lt;li&gt;如果不想讓 HintsColumnFamily 的資料保留時間過久，可以修改 coordinator node 的 cassandra.yaml 設定檔，將 max_hint_window_in_ms 設定值改小。這個設定值預設是 3600000，代表裡面的資料預設只保留 1 小時，時間超過時就會被系統自動清除&lt;/li&gt;
  &lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

  </channel>
</rss>
