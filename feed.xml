<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>老涂的咁仔店</title>
    <link>http://cloudtu.github.io</link>
    <atom:link href="http://cloudtu.github.io/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <description>老涂的咁仔店</description>
    <language>zh-TW</language>
    <pubDate>星期五, 12 三月 2021 20:22:19 +0800</pubDate>
    <lastBuildDate>星期五, 12 三月 2021 20:22:19 +0800</lastBuildDate>

    <item>
      <title>spring boot + spring security + jwt(json web token) 實作登入認証(authentication)與授權(authorization)</title>
      <link>http://cloudtu.github.io/blog/2021/03/spring-security-jwt-auth-teach.html</link>
      <pubDate>星期五, 12 三月 2021 18:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2021/03/spring-security-jwt-auth-teach.html</guid>
      <description>&lt;h2&gt;在開始之前&lt;/h2&gt;&lt;p&gt;建議先搞懂 spring security 裡的認証(authentication)與援權(authorization)功能的程式碼如何運作，不懂的可以看一下我之前寫的 &lt;a href=&quot;/blog/2021/03/spring-security-auth-memo.html&quot;&gt;spring security 裡的認証&amp;amp;援權原理說明&lt;/a&gt; ，把細節搞懂。不然看完實作範例後很可能不知道程式為何這樣寫就可以弄出 token base auth 功能，知其然不知其所以然。&lt;/p&gt;&lt;h2&gt;實作教學&lt;/h2&gt;&lt;p&gt;別人的教學文已經超詳細，直接看下列這些別人的文章吧 :)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;重拾後端之Spring Boot（四）：使用JWT和Spring Security保護REST API&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;文章在&lt;a href=&quot;https://www.jianshu.com/p/6307c89fe3fa&quot;&gt;這裡&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;sample code 在 &lt;a href=&quot;https://github.com/wpcfan/spring-boot-tut/tree/chap04&quot;&gt;git project&lt;/a&gt; 裡的 &lt;code&gt;chap04&lt;/code&gt; branch&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;Spring Boot Token based Authentication with Spring Security &amp;amp; JWT&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;文章在&lt;a href=&quot;https://bezkoder.com/spring-boot-jwt-authentication/&quot;&gt;這裡&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;sample code 在&lt;a href=&quot;https://github.com/bezkoder/spring-boot-spring-security-jwt-authentication&quot;&gt;這裡&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://bezkoder.com/spring-boot-jwt-mysql-spring-security-architecture/&quot;&gt;Spring Boot 2 JWT Authentication with Spring Security&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;Vincent Zheng blog 裡跟 Spring Security 相關系列文章&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;https://medium.com/chikuwa-tech-study/spring-boot-%E7%AC%AC17%E8%AA%B2-spring-security%E7%9A%84%E9%A9%97%E8%AD%89%E8%88%87%E6%8E%88%E6%AC%8A-263afe44ac20&quot;&gt;Spring Boot-第17課-Spring Security的驗證與授權&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://medium.com/chikuwa-tech-study/spring-boot-%E7%AC%AC18%E8%AA%B2-%E5%B8%B3%E5%AF%86%E9%A9%97%E8%AD%89%E8%88%87%E7%94%A2%E7%94%9Ftoken-79d9ccc2b6fd&quot;&gt;Spring Boot-第18課-帳密驗證與產生Token&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://medium.com/chikuwa-tech-study/spring-boot-%E7%AC%AC19%E8%AA%B2-%E5%BE%9Etoken%E9%A9%97%E8%AD%89%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E4%BB%BD-8818cca1361d&quot;&gt;Spring Boot-第19課-從Token驗證使用者身份&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;我改寫出來的教學範例程式&lt;/h2&gt;&lt;p&gt;不過，別人寫的教學範例程式提到的細節太多了，常會用到 NoSQL DB 或是 RMDB 來存放用戶個人資料，導致範例程式複雜化。所以我改寫出了一個簡化版的教學範例，放在&lt;a href=&quot;https://github.com/cloudtu/spring-security-jwt-auth-teach&quot;&gt;我的 github&lt;/a&gt;。程式裡關鍵處都有加上註解說明，有興趣的人可以看看。&lt;/p&gt;</description>
    </item>

    <item>
      <title>spring security 裡的認証(authentication) &amp; 援權(authorization) 原理說明</title>
      <link>http://cloudtu.github.io/blog/2021/03/spring-security-auth-memo.html</link>
      <pubDate>星期五, 12 三月 2021 08:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2021/03/spring-security-auth-memo.html</guid>
      <description>&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;要實作 spring security 裡面認証(authentication) &amp;amp; 援權(authorization) 功能時，大多數文件只會說要實作 UserDetailsService、UserDetails、WebSecurityConfigurerAdapter 這儿個 class 或 inteface 就可以搞定一切。但這儿個 class 間到底怎麼交互作用通常都不提，讓人覺得實作參考的範例程式碼很簡單易懂、但背後原理卻不知怎麼回事。程式這樣改一改就可以跑讓人覺得很像黑魔法，哪天要微調時很可能因為不知背後原理就改不動了。&lt;/p&gt;&lt;p&gt;因此我決定把背後原理搞清楚並整理出重點摘要。既然是摘要只會挑關鍵重點，建議搭配 spring security 裡的 source code 一起看，比較好理解內容。&lt;/p&gt;&lt;h2&gt;認証與援權功能的程式碼如何運作&lt;/h2&gt;&lt;p&gt;程式碼依照下列順序進行認証動作&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;用戶使用帳號和密碼進行登錄。&lt;/li&gt;
  &lt;li&gt;在 Filter 裡將獲取到的用戶名和密碼封裝成一個實現了 Authentication interface 的 UsernamePasswordAuthenticationToken。&lt;/li&gt;
  &lt;li&gt;將上述產生的 token 傳遞給 AuthenticationManager 進行登錄認證。&lt;/li&gt;
  &lt;li&gt;AuthenticationManager 認證成功後將會返回一個 &lt;code&gt;封裝了用戶權限等資料&lt;/code&gt; 的 Authentication 實例。而且這個實例內容裡 &lt;code&gt;不帶用戶憑証或密碼&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;通過呼叫 SecurityContextHolder.getContext().setAuthentication(...) method 將 AuthenticationManager 在認證成功後產生的 Authentication 實例賦予給當前的 SecurityContext。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上述流程項次 1,2,3,5 實作程式碼可參考 &lt;code&gt;BasicAuthenticationFilter.doFilterInternal(...)&lt;/code&gt; method，source code 與關鍵說明如下&lt;/p&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    @Override
    protected void doFilterInternal(HttpServletRequest request,HttpServletResponse response, FilterChain chain)
                    throws IOException, ServletException {
        ...略

        try {
            String[] tokens = extractAndDecodeHeader(header, request);

            String username = tokens[0];

            if (authenticationIsRequired(username)) {
                // step1. 將用戶輸入的帳號密碼轉換成 UsernamePasswordAuthenticationToken DTO
                UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, tokens[1]);
                authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));
                
                // step2. 利用 AuthenticationManager.authenticate(...) method 進行用戶認証
                //        認証失敗時丟出 Exception，認証成功時將用戶資料(指 UserDetails)、權限存
                //        成一個新的 Authentication DTO
                //
                //        AuthenticationManager.authenticate(...) method 裡的 &amp;quot;尋找用戶資料&amp;quot; 程式片段
                //        通常是呼叫 UserDetailsService.loadUserByUsername(...) method
                Authentication authResult = this.authenticationManager.authenticate(authRequest);

                // step3. SecurityContextHolder 存放授權成功的 Authentication DTO
                SecurityContextHolder.getContext().setAuthentication(authResult);
            }

        }
        catch (AuthenticationException failed) {
            // 授權失敗時，要把 SecurityContextHolder 裡的 Authentication DTO 清除
            SecurityContextHolder.clearContext();
        }

        ...略
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述流程項次 4 實作程式碼可參考 &lt;code&gt;AbstractUserDetailsAuthenticationProvider.authenticate(...)&lt;/code&gt; method，source code 與關鍵說明如下&lt;/p&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    public Authentication authenticate(Authentication authentication)throws AuthenticationException {
        ...略

        // Determine username
        String username = (authentication.getPrincipal() == null) ? &amp;quot;NONE_PROVIDED&amp;quot;: authentication.getName();

        boolean cacheWasUsed = true;
        UserDetails user = this.userCache.getUserFromCache(username);

        if (user == null) {
            cacheWasUsed = false;

            try {
                // step1. retrieveUser(...) method 呼叫 UserDetailsService.loadUserByUsername(...) method 
                //        查出用戶資料(指 UserDetails)
                user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication);
            }
            catch (UsernameNotFoundException notFound) {
                ...略

                throw notFound;
            }

        }

        try {
            ...略

            // step2. 用戶資料(指 UserDetails) 跟 UsernamePasswordAuthenticationToken 內容比對
            //        進行用戶認証，認証失敗時丟出 Exception。
            additionalAuthenticationChecks(user,(UsernamePasswordAuthenticationToken) authentication);
        }
        catch (AuthenticationException exception) {
            ...略

            throw exception;
        }

        ...略

        // step3. 認証成功時將用戶資料(指 UserDetails)、權限存成一個新的 Authentication DTO
        return createSuccessAuthentication(principalToReturn, authentication, user);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;認証與援權功能對應的關鍵 class 與 interface&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;Authentication&lt;/p&gt;&lt;p&gt;Authentication interface 用來存放用戶認證資料，在用戶登錄認證之前相關資料會封裝為一個 Authentication instance，在登錄認證成功之後又會生成一個資料更全面，包含用戶權限等資料的 Authentication instance，然後把它保存在 SecurityContextHolder 所持有的 SecurityContext 中，供後續的程序進行呼叫，如訪問權限的鑑定等。&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;Authentication.getPrincipal() : 認証成功前存放 &amp;quot;用戶登入id&amp;quot;，認証成功後存放 &amp;quot;用戶對應的 UserDetails&amp;quot;
Authentication.getCredentials() : 認証成功前存放 &amp;quot;用戶登入密碼&amp;quot;，認証成功後通常不帶任何資料
Authentication.getAuthorities() : 認証成功前不帶任何資料，認証成功後存放 &amp;quot;用戶權限&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;AuthenticationManager 和 AuthenticationProvider&lt;/p&gt;&lt;p&gt;AuthenticationManager 是一個用來處理認證（Authentication）請求的 interface，裡面只定義了 authenticate() 方法，該方法只接收一個代表認證請求的 Authentication 實例作為參數，如果認證成功，則會返回一個封裝了當前用戶權限等資料的 Authentication 實例進行返回。&lt;/p&gt;&lt;p&gt;AuthenticationManager 的預設實現是 ProviderManager。認證是由 AuthenticationManager 來管理的，但是真正進行認證的是 AuthenticationManager 中定義的 AuthenticationProvider。AuthenticationManager 中可以定義有多個 AuthenticationProvider。如果沒有指定對應關聯的 AuthenticationProvider 實例，Spring Security 預設會使用 DaoAuthenticationProvider。DaoAuthenticationProvider 在進行認證的時候需要一個 UserDetailsService 來獲取用戶的資料 UserDetails。&lt;/p&gt;&lt;p&gt;檢核認證請求最常用的方法是根據請求的用戶名產生對應的 UserDetails，然後比對 UserDetails 的密碼與認證請求的密碼是否一致，一致則表示認證通過。Spring Security 內部的 DaoAuthenticationProvider 就是使用的這種方式。其內部使用 UserDetailsService 來負責產生 UserDetails。在認證成功以後會產生包含用戶權限等資料的的 UserDetails 實例，並將它封裝在返回的認證成功 Authentication 實例。認證成功返回的 Authentication 實例將會保存在當前的 SecurityContext 中。預設情況下，在認證成功後 ProviderManager 將清除返回的 Authentication 中的憑證資料，如密碼。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;UserDetailsService&lt;/p&gt;&lt;p&gt;通過 Authentication.getPrincipal() 的返回類型是 Object，但很多情況下其返回的其實是一個 UserDetails 實例。UserDetails interface 定義了一些可以獲取用戶名、密碼、權限等與認證相關的資料的方法。登錄認證的時候 Spring Security 會通過 UserDetailsService 的 loadUserByUsername() 方法獲取對應的 UserDetails 進行認證，認證通過後會將該 UserDetails 放到認證通過的 Authentication 的 principal，然後再把該 Authentication 存入到 SecurityContext 中。之後如果需要使用用戶資料的時候就是通過 SecurityContextHolder 獲取存放在 SecurityContext 中的 Authentication 的 principal。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;GrantedAuthority&lt;/p&gt;&lt;p&gt;Authentication 的 getAuthorities() 可以返回當前 Authentication 實例擁有的權限，即當前用戶擁有的權限。其返回型別是 Collection&amp;lt;? extends GrantedAuthority&amp;gt;，每一個 GrantedAuthority 實例代表賦予給當前用戶的一種權限。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;SecurityContextHolder&lt;/p&gt;&lt;p&gt;SecurityContextHolder 是用來保存 SecurityContext，SecurityContext 中含有當前正在訪問系統的用戶的詳細資料。預設情況下，SecurityContextHolder 將使用 ThreadLocal 來保存 SecurityContext，這也就意味著在處於同一線程中的方法中我們可以從 ThreadLocal 中獲取到當前的 SecurityContext。&lt;/p&gt;&lt;p&gt;通過 &lt;code&gt;SecurityContextHolder.getContext().getAuthentication().getPrincipal()&lt;/code&gt; 可以獲取到代表當前已通過認証與授權的用戶資料，這個實例通常是 UserDetails 實例。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;所有 Filter 簡述&lt;/h2&gt;&lt;p&gt;Spring Security 底層是通過一系列的 Filter 來管理，每個 Filter 都有其自身的功能，而且各個 Filter 在功能上還有關聯關係，所以它們的順序也是非常重要的。Spring Security 對 FilterChain 中 Filter 順序有嚴格的規定的，Spring Security 對那些預設的 Filter 指定了它們的位置。&lt;/p&gt;&lt;p&gt;Spring Security 已經定義了一些 Filter，不管實際應用中你用到了哪些，它們應當保持如下順序。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;p&gt;ChannelProcessingFilter&lt;/p&gt;&lt;p&gt;如果你訪問的 channel 錯了，那首先就會在 channel 之間進行跳轉，如 http 變為 https。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;SecurityContextPersistenceFilter&lt;/p&gt;&lt;p&gt;開始進行 request 的時候就可以在 SecurityContextHolder 中建立一個 SecurityContext，然後在請求結束的時候，任何對 SecurityContext 的改變都可以被 copy 到 HttpSession。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;ConcurrentSessionFilter&lt;/p&gt;&lt;p&gt;它使用 SecurityContextHolder 的功能，而且更新對應 session 的最後更新時間，以及通過 SessionRegistry 獲取當前的 SessionInformation 以檢查當前的 session 是否已經過期，過期則會呼叫 LogoutHandler。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;認證處理機制&lt;/p&gt;&lt;p&gt;如 UsernamePasswordAuthenticationFilter，CasAuthenticationFilter，BasicAuthenticationFilter 等，以至於 SecurityContextHolder 可以被更新為包含一個有效的 Authentication 請求。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;SecurityContextHolderAwareRequestFilter&lt;/p&gt;&lt;p&gt;它將會把 HttpServletRequest 封裝成一個繼承自 HttpServletRequestWrapper 的 SecurityContextHolderAwareRequestWrapper，同時使用 SecurityContext 實現了 HttpServletRequest 中與安全相關的方法。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;JaasApiIntegrationFilter&lt;/p&gt;&lt;p&gt;如果 SecurityContextHolder 中擁有的 Authentication 是一個 JaasAuthenticationToken，那麼該 Filter 將使用包含在 JaasAuthenticationToken 中的 Subject 繼續執行 FilterChain。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;RememberMeAuthenticationFilter&lt;/p&gt;&lt;p&gt;如果之前的認證處理機制沒有更新 SecurityContextHolder，並且用戶請求包含了一個 Remember-Me 對應的 cookie，那麼一個對應的 Authentication 將會設給 SecurityContextHolder。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;AnonymousAuthenticationFilter&lt;/p&gt;&lt;p&gt;如果之前的認證機制都沒有更新 SecurityContextHolder 擁有的 Authentication，那麼一個 AnonymousAuthenticationToken 將會設給 SecurityContextHolder。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;ExceptionTransactionFilter&lt;/p&gt;&lt;p&gt;用於處理在 FilterChain 範圍內拋出的 AccessDeniedException 和 AuthenticationException，並把它們轉換為對應的 Http 錯誤碼返回或者對應的頁面。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;FilterSecurityInterceptor，保護 Web URI，並且在訪問被拒絕時拋出異常。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;reference document&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/spring-security/&quot;&gt;初識 Spring Security&lt;/a&gt;&lt;/p&gt;&lt;p&gt;認証與援權功能在下述這儿個章節&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;核心類簡介&lt;/li&gt;
    &lt;li&gt;認證簡介&lt;/li&gt;
    &lt;li&gt;AuthenticationProvider&lt;/li&gt;
    &lt;li&gt;Filter&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5a4f213af265da3e3c6bf47d&quot;&gt;Spring Security源碼分析二：Spring Security授權過程&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.baeldung.com/get-user-in-spring-security&quot;&gt;retrieve the user details in Spring Security&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5a1980825188252abc5e0fd1&quot;&gt;聊聊 spring security 的 permitAll 以及 ignore&lt;/a&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;permitAll() 情況下，每個 reqeust 還是會走過所有 filter&lt;/li&gt;
    &lt;li&gt;ignoring() 清況下，每個 reqeust 不會走過任何 filter，相當於不走 spring security&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>

    <item>
      <title>Guava Cache 使用說明</title>
      <link>http://cloudtu.github.io/blog/2018/08/guava-cache-memo.html</link>
      <pubDate>星期三, 29 八月 2018 20:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2018/08/guava-cache-memo.html</guid>
      <description>&lt;h2&gt;基本用法&lt;/h2&gt;&lt;p&gt;請參考下列文章&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000011105644&quot;&gt;Guava Cache 用法介紹&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;CacheBuilder class 裡的 expireAfterWrite, expireAfterAccess, refreshAfterWrite method 區別&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;expireAfterAccess&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;一定時間內沒有讀寫，會移除該cache key，下次取的時候從 raw data (e.g. database) 裡取&lt;/li&gt;
    &lt;li&gt;在更新 cache key 對應內容時，會 &lt;code&gt;block&lt;/code&gt; 所有存取該 cache key 的 thread&lt;/li&gt;
    &lt;li&gt;expireAfterAccess 行為分析請參考下列文章
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/aitangyong/article/details/53491867&quot;&gt;Guava Cache特性：對於同一個key，只讓一個請求回源load數據，其他線程阻塞等待結果&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;expireAfterWrite&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;一定時間內沒有創建或覆寫時，會移除該 cache key，下次取的時候從 raw data (e.g. database) 裡取&lt;/li&gt;
    &lt;li&gt;在更新 cache key 對應內容時，會 &lt;code&gt;block&lt;/code&gt; 所有存取該 cache key 的所有 thread&lt;/li&gt;
    &lt;li&gt;expireAfterWrite 是時間到了就 expire。expireAfterAccess 則是以 &lt;code&gt;上次取存的時間點&lt;/code&gt; 為基準來記算何時會 expire，也就是說只要一直被存取就不會 expire&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;refreshAfterWrite&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;指定時間內沒有被創建或覆寫，在指定時間過後再次訪問時，會去更新 cache key 對應之值，在新值沒有到來之前，始終返回舊值。&lt;code&gt;注意!是再次訪問，也就是未訪問前可能都不會更新。&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;在更新 cache key 對應內容時，&lt;code&gt;不會 block&lt;/code&gt; 所有存取該 cache key 的 thread&lt;/li&gt;
    &lt;li&gt;CacheBuilder 要產生 LoadingCache 時才可以叫用這個 method，不然會產生 &lt;code&gt;refreshAfterWrite requires a LoadingCache&lt;/code&gt; exception&lt;/li&gt;
    &lt;li&gt;跟 expireAfterAccess(或 expireAfterWrite) 區別
    &lt;ul&gt;
      &lt;li&gt;指定時間過後，expireAfterAccess(或 expireAfterWrite) 是 remove cache key，下次訪問是 &lt;code&gt;同步(sync)&lt;/code&gt; 去獲取返回新值。新值未取回前，所有要取新值 的 thread 都會被 block。&lt;/li&gt;
      &lt;li&gt;refresh 是指定時間後，不會 remove cache key，&lt;code&gt;直到下次訪問&lt;/code&gt; 才以 &lt;code&gt;非同步(async)&lt;/code&gt; 方式 refresh cache。在 refresh cache 動作完成前，大多數針對該 cache key 的請求 thread 會立刻返回舊值，不會被 block&lt;/li&gt;
    &lt;/ul&gt;&lt;/li&gt;
    &lt;li&gt;refreshAfterWrite 行為分析請參考下列文章
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/aitangyong/article/details/53504253&quot;&gt;Guava Cache特性：refreshAfterWrite只阻塞回源線程，其他線程返回舊值&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;CacheBuilder class 裡的 expireAfterWrite, refreshAfterWrite method 可以一起使用&lt;/h2&gt;&lt;p&gt;二者一起使用時的行為請參考下列文章&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/abc86319253/article/details/53020432&quot;&gt;深入Guava Cache的refresh和expire刷新機制&lt;/a&gt;&lt;/p&gt;&lt;p&gt;重點是這一段&lt;/p&gt;
  &lt;blockquote&gt;&lt;p&gt;可以看出refreshAfterWrite和expireAfterWrite兩種方式各有優缺點，各有使用場景。那麼能否在refreshAfterWrite和expireAfterWrite找到一個折中？比如說控制緩存每1s進行refresh，如果超過2s沒有訪問，那麼則讓緩存失效，下次訪問時不會得到舊值，而是必須得待新值加載。由於guava官方文檔沒有給出一個詳細的解釋，查閱一些網上資料也沒有得到答案，因此只能對源碼進行分析，尋找答案。經過分析，當同時使用兩者的時候，可以達到預想的效果，這真是一個好消息吶！&lt;/p&gt;
  &lt;/blockquote&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/google/guava/wiki/CachesExplained#refresh&quot;&gt;官方文件說明&lt;/a&gt;&lt;/p&gt;&lt;p&gt;重點是這一段，不過我沒有很懂它表達的意思&lt;/p&gt;
  &lt;blockquote&gt;&lt;p&gt;In contrast to expireAfterWrite, refreshAfterWrite will make a key eligible for refresh after the specified duration, but a refresh will only be actually initiated when the entry is queried. (If CacheLoader.reload is implemented to be asynchronous, then the query will not be slowed down by the refresh.) So, for example, you can specify both refreshAfterWrite and expireAfterWrite on the same cache, so that the expiration timer on an entry isn&#39;t blindly reset whenever an entry becomes eligible for a refresh, so if an entry isn&#39;t queried after it comes eligible for refreshing, it is allowed to expire.&lt;/p&gt;
  &lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;reference document&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000011105644&quot;&gt;Guava Cache 用法介紹&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/aitangyong/article/details/53491867&quot;&gt;Guava Cache特性：對於同一個key，只讓一個請求回源load數據，其他線程阻塞等待結果&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/aitangyong/article/details/53504253&quot;&gt;Guava Cache特性：refreshAfterWrite只阻塞回源線程，其他線程返回舊值&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://my.oschina.net/scipio/blog/551475&quot;&gt;guava緩存的expireAfterWrite與refreshAfterWrite的區別&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/abc86319253/article/details/53020432&quot;&gt;深入Guava Cache的refresh和expire刷新機制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>

    <item>
      <title>如何在 spring 實作的 restful api 裡使用 validation annotation</title>
      <link>http://cloudtu.github.io/blog/2017/12/spring-restful-api-input-param-validate-memo.html</link>
      <pubDate>星期五, 29 十二月 2017 20:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2017/12/spring-restful-api-input-param-validate-memo.html</guid>
      <description>&lt;h2&gt;如何實作&lt;/h2&gt;&lt;p&gt;spring 實作的 restful api，要針對輸入參數進行內容格式驗証，可分成下列儿類&lt;/p&gt;&lt;h3&gt;針對 @RequestBody 進行 validation&lt;/h3&gt;&lt;p&gt;實作程式碼重點如下&lt;/p&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@RestController
@RequestMapping(&amp;quot;/validateAnnotationDemo&amp;quot;)
public class ValidateAnnotationDemoController {
    @RequestMapping(value = &amp;quot;/validateRequestBody&amp;quot;, produces = MediaType.APPLICATION_JSON_VALUE)
    public User validateRequestBody(@Valid @RequestBody User user){
        ...etc;
    }

    private static class User{
        @NotBlank
        private String name;
        ...etc;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity handleMethodArgumentNotValidException(HttpServletRequest req, MethodArgumentNotValidException e) {
        ...etc;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
  &lt;li&gt;@RequestBody 前面要加上 @Valid&lt;/li&gt;
  &lt;li&gt;pojo (在此例指 User class) 要加上 validation annotation (e.g. @NotBlank, @NotNull ...etc)&lt;/li&gt;
  &lt;li&gt;validate fail 會丟出 MethodArgumentNotValidException，要自己寫 handler 決定哪些異常明細回傳給前端&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;針對 @RequestParam 進行 validation&lt;/h3&gt;&lt;p&gt;實作程式碼重點如下&lt;/p&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Configuration
@ComponentScan
public class WebConfig {
    @Bean
    public MethodValidationPostProcessor methodValidationPostProcessor() {
        return new MethodValidationPostProcessor();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Validated
@RestController
@RequestMapping(&amp;quot;/validateAnnotationDemo&amp;quot;)
public class ValidateAnnotationDemoController {
    @RequestMapping(value = &amp;quot;/validateRequestParam&amp;quot;, produces = MediaType.APPLICATION_JSON_VALUE)
    public Map&amp;lt;String,Object&amp;gt; validateRequestParam(@NotBlank(message = &amp;quot;message must not be blank&amp;quot;) @RequestParam String message){
        ...etc;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity handleConstraintViolationException(HttpServletRequest req, ConstraintViolationException e){
        ...etc;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
  &lt;li&gt;要注冊 MethodValidationPostProcessor bean，不然無法對 @RequestParam 進行 validation&lt;/li&gt;
  &lt;li&gt;在 @RestController 前面加上 @Validated&lt;/li&gt;
  &lt;li&gt;在 @RequestParam 前面加上 validation annotation (e.g. @NotBlank, @NotNull ...etc)&lt;/li&gt;
  &lt;li&gt;validate fail 會丟出 ConstraintViolationException，要自己寫 handler 決定哪些異常明細回傳給前端&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;完整範例&lt;/h2&gt;&lt;h3&gt;WebConfig.java&lt;/h3&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Configuration
@ComponentScan
public class WebConfig {

    /**
     * 注冊 MethodValidationPostProcessor bean 之後，Controller class 開頭加的 @Validated 與 method 裡針
     * 對 @RequestParam annotation 加的 validate annotation (e.g. @NotBlank, @NotNull ...etc)才會生效，
     * 沒注冊時就算程式碼裡有加這些 annotation 還是不會有作用
     *
     * @return
     */
    @Bean
    public MethodValidationPostProcessor methodValidationPostProcessor() {
        return new MethodValidationPostProcessor();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;ValidateAnnotationDemoController.java&lt;/h3&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Validated
@RestController
@RequestMapping(&amp;quot;/validateAnnotationDemo&amp;quot;)
public class ValidateAnnotationDemoController {

    //在 class 開頭加了 @Validated 之後，針對 @RequestParam 加的 validation annotation (e.g. @NotBlank, @NotNull...etc) 才會生效
    @RequestMapping(value = &amp;quot;/validateRequestParam&amp;quot;, produces = MediaType.APPLICATION_JSON_VALUE)
    public Map&amp;lt;String,Object&amp;gt; validateRequestParam(
            @NotBlank(message = &amp;quot;message must not be blank&amp;quot;) @RequestParam String message){
        Map&amp;lt;String,Object&amp;gt; result = new HashMap&amp;lt;&amp;gt;();
        result.put(&amp;quot;message&amp;quot;, message);
        return result;
    }

    // 加對 @Valid 之後，會驗証 pojo (此例中指 User instance) 內容格式是否正確
    @RequestMapping(value = &amp;quot;/validateRequestBody&amp;quot;, produces = MediaType.APPLICATION_JSON_VALUE)
    public User validateRequestBody(@Valid @RequestBody User user){
        return user;
    }

    private static class User{
        @NotBlank
        private String name;

        // 針對 list of pojo 的資料格式進行驗証，要加上 @NotEmpty, @Valid 二個 annotation
        @NotEmpty
        @Valid
        private List&amp;lt;ContactInfo&amp;gt; contactInfoList;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public List&amp;lt;ContactInfo&amp;gt; getContactInfoList() {
            return contactInfoList;
        }

        public void setContactInfoList(List&amp;lt;ContactInfo&amp;gt; contactInfoList) {
            this.contactInfoList = contactInfoList;
        }
    }

    private static class ContactInfo{
        @NotBlank
        private String address;

        public String getAddress() {
            return address;
        }

        public void setAddress(String address) {
            this.address = address;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;GlobalExceptionHandler.java&lt;/h3&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * Controller 發生 uncatch exception 情況時，會統一在這個 class 被處理。
 */
@ControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(Exception.class)
    public ResponseEntity handleException(HttpServletRequest req, Exception e){
        logger.error(e.getMessage(), e);
        String errorMsg = (e.getMessage() == null) ? e.getClass().getSimpleName() : e.getMessage();
        Map&amp;lt;String,Object&amp;gt; error = Collections.singletonMap(&amp;quot;error&amp;quot;, errorMsg);
        return ResponseEntity.status(500).body(error);
    }

    /**
     * Controller 裡標注 @RequestParam 的變數在 validate fail 時會丟出 ConstraintViolationException。這個 method
     * 專門處理此類 exception
     *
     * @param req
     * @param e
     *
     * @return
     */
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity handleConstraintViolationException(HttpServletRequest req, ConstraintViolationException e){
        logger.error(e.getMessage(), e);
        // &amp;quot;@NotBlank @RequestParam String myArg&amp;quot; 這樣的 validate 寫法在 validate fail 時無法得知 &amp;quot;哪個輸入參數名稱&amp;quot; 驗証失敗，這是 java reflection 本身的限制。
        // 用這類語法時要改寫成 &amp;quot;@NotBlank(myArg must not be blank) @RequestParam String myArg&amp;quot;，程式裡的 validate annotation 要寫出 &amp;quot;完整出錯明細&amp;quot;，
        // 不然在處理 ConstraintViolationException 時只會知道驗証失敗的原因，卻不知道是哪個輸入參數名稱驗証失敗。
        List&amp;lt;String&amp;gt; errorMessages = e.getConstraintViolations()
                .stream()
                .map(ConstraintViolation::getMessage)
                .collect(Collectors.toList());
        Map&amp;lt;String,Object&amp;gt; error = Collections.singletonMap(&amp;quot;error&amp;quot;, errorMessages);
        return ResponseEntity.status(400).body(error);
    }

    /**
     * Controller 裡標注 @RequestBody 的變數在 validate fail 時會丟出 MethodArgumentNotValidException。這個 method
     * 專門處理此類 exception
     *
     * @param req
     * @param e
     *
     * @return
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity handleMethodArgumentNotValidException(HttpServletRequest req, MethodArgumentNotValidException e) {
        logger.error(e.getMessage(), e);
        List&amp;lt;String&amp;gt; errorMessages = e.getBindingResult().getFieldErrors()
                .stream()
                .map(fieldError -&amp;gt; fieldError.getField() + &amp;quot; &amp;quot; + fieldError.getDefaultMessage()) // 記錄 &amp;quot;fieldName + validateFailMessage&amp;quot;
                .collect(Collectors.toList());
        Map&amp;lt;String,Object&amp;gt; error = Collections.singletonMap(&amp;quot;error&amp;quot;, errorMessages);
        return ResponseEntity.status(400).body(error);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;reference document&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/51e8d2702ca1&quot;&gt;在Spring MVC中使用註解的方式校驗RequestParams&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://sdqali.in/blog/2015/12/04/validating-requestparams-and-pathvariables-in-spring-mvc/&quot;&gt;Validating RequestParams and PathVariables in Spring MVC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/38615327/8646444&quot;&gt;Spring Boot REST @RequestParam not being Validated&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/35588953/8646444&quot;&gt;Spring MVC - @Valid on list of beans in REST service&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>

    <item>
      <title>MAC 新手入門筆記</title>
      <link>http://cloudtu.github.io/blog/2016/02/mac-memo-for-beginner.html</link>
      <pubDate>星期五, 4 三月 2016 18:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2016/02/mac-memo-for-beginner.html</guid>
      <description>&lt;p&gt;儿個月前因為工作需要摸了一陣子 MAC 筆電，有一些簡單心得，所以做個筆記以備未來不時之需 :)&lt;/p&gt;&lt;h2&gt;MAC OS 入門影片&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;英文
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=wSPisJXyjso&quot;&gt;Learn the MAC In Under 90 Minutes 2015 Yosemite Edition&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=kgS6E-6vStA&quot;&gt;El Capitan OS X Tutorial&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;中文
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLtDm33ESx3munKRdCXwvw4Bge2k2b-RZh&quot;&gt;Mac OS X 基礎教學&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PL7A481B6116A5B721&quot;&gt;Mac 相關教學&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;MAC OS 入門文件&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://appleuser.com/mac-os-x-teach-all/&quot;&gt;Mac 新手教學區&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://mac-osx-for-newbie-book.kejyun.com/&quot;&gt;Mac OSX 新手入門&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.playpcesor.com/2014/01/mac-macbook-air.html&quot;&gt;[Mac 新手日記] 讓 Macbook Air 靈活百倍的觸控板手勢教學&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.playpcesor.com/2015/04/mac-10-finder.html&quot;&gt;Mac 用戶一定要知道這10個 Finder 獨特檔案整理技巧&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.playpcesor.com/2014/01/mac-apple-mac-os-x.html&quot;&gt;[Mac 新手日記] Apple Mac OS X 截圖文書必備快捷鍵教學&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.playpcesor.com/2015/05/Mac-preview-photo-pdf-editor.html&quot;&gt;Mac 用戶不可不用預覽程式：13招取代修圖 PDF 軟體&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.playpcesor.com/2015/04/mac-photos-app-14.html&quot;&gt;Mac 全新內建 Photos 照片 App 你一定要會的14件事&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.playpcesor.com/2014/03/mac-quicktime-player.html&quot;&gt;[Mac 新手日記] QuickTime Player 螢幕錄影與影片剪輯教學&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;SSH 相關 console command&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;p&gt;產生 SSH 公私鑰&lt;/p&gt;
  &lt;!--?prettify?--&gt;
  &lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;Storing Passphrases in the Keychain, 免除每次 ssh 連線都要指定 private key 所在位置&lt;/p&gt;
  &lt;!--?prettify?--&gt;
  &lt;pre&gt;&lt;code&gt;ssh-add -K /path/to/private/key/file
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;相關參考文件&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.longwin.com.tw/2005/12/ssh_keygen_no_passwd/&quot;&gt;http://blog.longwin.com.tw/2005/12/ssh_keygen_no_passwd/&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://ekkescorner.wordpress.com/blog-series/git-mercurial/step-by-step-ssh-on-osx-ubuntu-and-windows/&quot;&gt;https://ekkescorner.wordpress.com/blog-series/git-mercurial/step-by-step-ssh-on-osx-ubuntu-and-windows/&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/a/11673152&quot;&gt;http://stackoverflow.com/a/11673152&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;利用 homebrew 指令安裝軟體&lt;/h2&gt;&lt;p&gt;homebrew 可以幫你用 &lt;code&gt;console command&lt;/code&gt; 的方式安裝與管理各種軟體，可以讓你在這方面省掉很多時間，強烈推薦要用這個好物。下面列的是我常會利用 homebrew 安裝的軟體。&lt;/p&gt;
&lt;!--?prettify?--&gt;
&lt;pre&gt;&lt;code&gt;# install xcode command tool
xcode-select --install
# check xcode command tool
xcode-select -p

# install homebrew
ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
# check homebrew install success or not
brew doctor
brew update

# install homebrew-cask
brew tap caskroom/cask
brew install brew-cask

# i install these soft below by brew &amp;amp; brew-cask

brew install wget
brew install curl
brew install git
brew install htop-osx

# install java7
brew cask install caskroom/versions/java7
# install java8
brew cask install java

brew cask install intellij-idea-ce
brew cask install eclipse-jee

brew install maven
brew install gradle

brew cask install sourcetree
brew cask install cyberduck
brew cask install dbeaver-enterprise

brew cask install google-chrome
brew cask install firefox
brew cask install flash

brew cask install bettertouchtool
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;其它實用的教學文件&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://aimijia.net/2014/05/each-mac-os-x-command-line-users-should-be-aware-of-the-eight-terminal-tool/&quot;&gt;【譯】每個Mac OS X 命令行用戶應當知道的八個終端工具&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>

    <item>
      <title>spring boot 官方文件摘要</title>
      <link>http://cloudtu.github.io/blog/2015/09/spring-boot-official-doc-memo.html</link>
      <pubDate>星期三, 9 九月 2015 20:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/09/spring-boot-official-doc-memo.html</guid>
      <description>&lt;p&gt;這篇內容寫的是 &lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/&quot;&gt;spring boot 1.2.5 官方文件&lt;/a&gt; 重點摘要，不做 spring boot 基礎教學。要看懂這些內容有下列前題假設&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;會用 java 寫 spring boot 程式&lt;/li&gt;
  &lt;li&gt;會用 gradle 寫 build script&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果你完全不懂 spring boot，建議看一下 Bootify your spring application (&lt;a href=&quot;http://www.slideshare.net/gn00023040/bootify-your-spring-application&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=PTIRJZUMf78&quot;&gt;錄影&lt;/a&gt;)，看完後會對 spring boot 有基本認知，有助於日後快速上手。&lt;/p&gt;&lt;h2&gt;spring-boot-teach 教學程式解說&lt;/h2&gt;&lt;p&gt;我針對官方文件寫了個 &lt;a href=&quot;https://github.com/cloudtu/spring-boot-teach&quot;&gt;spring-boot-teach 教學程式&lt;/a&gt; 放在 github 上，請把它抓回來看看程式怎麼寫、怎麼運作。此外，這節出現的範列在內容上有前後關係，所以這節內容不要跳著看，不然會發生看完後卻看不懂在講什麼的鳥事&lt;/p&gt;&lt;h3&gt;程式目錄結構&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/img/2015/09/spring-boot-teach-folder-structure.png&quot; alt=&quot;教學程式目錄結構&quot;&quot;/&gt;&lt;/p&gt;&lt;h3&gt;application-context.xml&lt;/h3&gt;
&lt;!--?prettify?--&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
    xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
    xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
    xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;

    &amp;lt;bean id=&amp;quot;hello&amp;quot; class=&amp;quot;cloudtu.bean.Hello&amp;quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這個 spring xml 設定檔會在 java config 時被匯入&lt;/p&gt;&lt;h3&gt;application.properties&lt;/h3&gt;
&lt;!--?prettify?--&gt;
&lt;pre&gt;&lt;code&gt;server.port=8080
# enable Tomcat&amp;#39;s HTTP response compression
server.tomcat.compression=on

# set actuator HTTP port  
management.port=8081
# 只許可經由內網網址連入 actuator，可避免監控資料外流
management.address=127.0.0.1

welcome.first-message=java run anywhere
welcome.secondMessage=spring boot is easy to use

appVersion=1.0.0

db.prd.name=prd123
db.dev.name=dev456
# 設定要啟用哪些 profile
spring.profiles.active=dev
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;application.properties&lt;/code&gt; 是 spring boot 預設的外部設定檔。因為我針對 actuator 功能設定了 &lt;code&gt;management.port=8081&lt;/code&gt;、&lt;code&gt;management.address=127.0.0.1&lt;/code&gt;，所以只能用 &lt;code&gt;http://127.0.0.1:8081/${actuator_endpoint}&lt;/code&gt; 這類網址才可以取得 actuator 提供的資訊&lt;/p&gt;&lt;h3&gt;author.properties&lt;/h3&gt;
&lt;!--?prettify?--&gt;
&lt;pre&gt;&lt;code&gt;author.name=cloudtu
author.department=RD team
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了 &lt;code&gt;application.properties&lt;/code&gt; 之外自訂的設定檔，之後會提供給 author bean 使用&lt;/p&gt;&lt;h3&gt;Application.java&lt;/h3&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package cloudtu;

...etc
import cloudtu.bean.Author;
import cloudtu.bean.DbName;

// @SpringBootApplication = @Configuration + @EnableAutoConfiguration + @ComponentScan
@SpringBootApplication
// 匯入 XML 格式的 spring 設定檔
@ImportResource(&amp;quot;classpath:application-context.xml&amp;quot;)
// 設定 property file 設定檔的來源位置
@PropertySource(&amp;quot;classpath:author.properties&amp;quot;)
public class Application {
    ...etc

    // author.properties 裡的 author.* 設定會自動綁定到 authorName, authorDept 變數
    @Value(&amp;quot;${author.name}&amp;quot;) private String authorName;
    @Value(&amp;quot;${author.department}&amp;quot;) private String authorDept;

    @Bean
    public Author author(){
        Author author = new Author();
        // 手工指定 author bean 裡的各項 setter 設定
        author.setName(authorName);
        author.setDepartment(authorDept);
        return author;
    }

    @Bean
    // application.properties 裡的 db.prd.* 設定會自動綁定到 prdDbName bean
    @ConfigurationProperties(prefix=&amp;quot;db.prd&amp;quot;)
    @Profile(&amp;quot;prd&amp;quot;)
    public DbName prdDbName(){
        return new DbName();
    }

    @Bean
    // application.properties 裡的 db.dev.* 設定會自動綁定到 devDbName bean
    @ConfigurationProperties(prefix=&amp;quot;db.dev&amp;quot;)
    @Profile(&amp;quot;dev&amp;quot;)
    public DbName devDbName(){
        return new DbName();
    }

    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(Application.class, args);
        ...etc
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;程式碼關鍵處都加了註解，所以看完後你應該知道裡面各個 annotation 用法，不過有儿個地方再補充說明一下。&lt;br/&gt;1. &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 可以把 *.property 設定檔的設定值經由各個 bean 的 setter 進行自動綁定動作&lt;br/&gt;2. 在 &lt;code&gt;application.properties&lt;/code&gt; 裡設定了 &lt;code&gt;spring.profiles.active=dev&lt;/code&gt;，所以程式裡有 &lt;code&gt;@Profile(&amp;quot;dev&amp;quot;)&lt;/code&gt; 宣告的 devDbName bean 在執行時會產生，但是有 &lt;code&gt;@Profile(&amp;quot;prd&amp;quot;)&lt;/code&gt; 宣告的 prdDbName bean 在執行時不會產生&lt;/p&gt;&lt;h3&gt;Welcome.java&lt;/h3&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package cloudtu.bean;

...etc
@Component
// application.properties 裡的 welcome.* 設定會自動綁定到 welcome bean
@ConfigurationProperties(prefix=&amp;quot;welcome&amp;quot;)
public class Welcome {
    private String firstMessage;
    private String secondMessage;

    // application.properties 裡的 welcome.first-message 設定綁定到 firstMessage instance variable
    public void setFirstMessage(String firstMessage) {
        this.firstMessage = firstMessage;
    }
    // application.properties 裡的 welcome.secondMessage 設定綁定到 secondMessage instance variable
    public void setSecondMessage(String secondMessage) {
        this.secondMessage = secondMessage;
    }
    ...etc
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這個範例也是在介紹 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 用法，不過你會發現設定檔裡的名稱格式不一致， &lt;code&gt;welcome.first-message&lt;/code&gt; 用 &lt;code&gt;-&lt;/code&gt; 當變數名稱裡的分隔符號，另一個 &lt;code&gt;welcome.secondMessage&lt;/code&gt; 則是用 lower camel case 命名方式。這兩種設定方式 spirng boot 都可以接受&lt;/p&gt;&lt;h3&gt;AppVersion.java&lt;/h3&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package cloudtu.bean;

...etc
@Component
public class AppVersion {
    // application.properties 裡的 appVersion 設定會自動綁定到 appVersion 變數
    @Value(&amp;quot;${appVersion}&amp;quot;) String appVersion;
    ...etc
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;application.properties&lt;/code&gt; 裡的設定可以用 &lt;code&gt;@Value(&amp;quot;${appVersion}&amp;quot;)&lt;/code&gt; 這類的宣告方式直接綁定到 bean 裡面&lt;/p&gt;&lt;h3&gt;Filters.java&lt;/h3&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package cloudtu.web;

...etc
@Configuration
public class Filters{
    ...etc

    // spring boot 預設的 url mapping 是  &amp;quot;/*&amp;quot;，所以任何 request 都會經過 firstFilter bean
    @Component
    private static class FirstFilter implements Filter{
        ...etc
    }

    private static class SecondFilter implements Filter{
        ...etc
    }

    @Bean
    public FilterRegistrationBean secondFilter(){
        FilterRegistrationBean registration = new FilterRegistrationBean(new SecondFilter());
        // 改寫掉預設的 url mapping，只有 &amp;quot;/hello&amp;quot; 的 request 會經過 secondFilter bean
        registration.addUrlPatterns(&amp;quot;/hello&amp;quot;);
        return registration;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;Filter&lt;/code&gt; 可以直接加 &lt;code&gt;@Component&lt;/code&gt; 讓它變成 spring 裡的 bean，firstFilter bean 就是這樣宣告。但是這樣宣告 filter 會讓它的 url mapping 固定都是 &lt;code&gt;/*&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;如果想自定 url mapping，要用 &lt;code&gt;FilterRegistrationBean&lt;/code&gt; 把 &lt;code&gt;Filter&lt;/code&gt; 給包起來，secondFilter bean 就是在講自訂 url mapping 的寫法&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;官方文件裡與教學程式相關的章節&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;configuration
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#getting-started-first-application-auto-configuration&quot;&gt;11.3.2 The @EnableAutoConfiguration annotation&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#using-boot-importing-configuration&quot;&gt;15.1 Importing additional configuration classes&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#using-boot-importing-xml-configuration&quot;&gt;15.2 Importing XML configuration&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#using-boot-structuring-your-code&quot;&gt;18. Using the @SpringBootApplication annotation&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features&quot;&gt;23. Externalized Configuration&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-external-config-command-line-args&quot;&gt;23.2 Accessing command line properties&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-external-config-application-property-files&quot;&gt;23.3 Application property files&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-external-config-placeholders-in-properties&quot;&gt;23.5 Placeholders in properties&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-external-config-typesafe-configuration-properties&quot;&gt;23.7 Typesafe Configuration Properties&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-profiles&quot;&gt;24. Profiles&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-understanding-auto-configured-beans&quot;&gt;36.1 Understanding auto-configured beans&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#common-application-properties&quot;&gt;Appendix A. Common application properties&lt;/a&gt; : 有 &lt;code&gt;application.properties&lt;/code&gt; 常用參數名稱與用途說明&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;web developing
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#_servlet_containers&quot;&gt;9.1 Servlet containers&lt;/a&gt; : 有支援的 embedded servlet containers 明細列表&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications&quot;&gt;26. Developing web applications&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration&quot;&gt;26.1.1 Spring MVC auto-configuration&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-static-content&quot;&gt;26.1.4 Static Content&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-template-engines&quot;&gt;26.1.5 Template engines&lt;/a&gt; : 有支援的 template engine 清單&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-embedded-container-servlets-and-filters&quot;&gt;26.3.1 Servlets and Filters&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-customizing-embedded-containers&quot;&gt;26.3.3 Customizing embedded servlet containers&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-jsp-limitations&quot;&gt;26.3.4 JSP limitations&lt;/a&gt; : 有寫 JSP 的人要注意一下 sprint boot 在 JSP 方面的限制&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;官方範列程式&lt;/h2&gt;&lt;p&gt;官方在 github 有放 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples&quot;&gt;spring boot 官方範列程式&lt;/a&gt;，搞不懂某些功能怎麼用時可以去那邊找找有沒有解答&lt;/p&gt;&lt;h2&gt;Testing&lt;/h2&gt;&lt;p&gt;官方文件裡較重要相關章節條列如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications&quot;&gt;35.3 Testing Spring Boot applications&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#boot-features-rest-templates-test-utility&quot;&gt;35.4.4 TestRestTemplate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;監控管理&lt;/h2&gt;&lt;p&gt;官方文件裡較重要相關章節條列如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#production-ready-endpoints&quot;&gt;40. Actuator endpoints&lt;/a&gt; : 有 actuator endpoints 明細列表&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#production-ready-sensitive-endpoints&quot;&gt;41.1 Securing sensitive endpoints&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#production-ready-customizing-management-server-port&quot;&gt;41.3 Customizing the management server port&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#production-ready-metrics&quot;&gt;44. Metrics&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#production-ready-system-metrics&quot;&gt;44.1 System metrics&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#production-ready-datasource-metrics&quot;&gt;44.2 DataSource metrics&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#production-ready-session-metrics&quot;&gt;44.3 Tomcat session metrics&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#production-ready-tracing&quot;&gt;46. Tracing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Build by gradle&lt;/h2&gt;&lt;h3&gt;spring-boot-teach 教學程式裡的 build.gradle&lt;/h3&gt;
&lt;!--?prettify?--&gt;
&lt;pre&gt;&lt;code&gt;buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath(&amp;quot;org.springframework.boot:spring-boot-gradle-plugin:1.2.5.RELEASE&amp;quot;)
    }
}

// 引用 spring boot plugin
apply plugin: &amp;quot;spring-boot&amp;quot;
...etc

configurations {
    providedRuntime

    // spring boot 預設使用 logback 但是我要用 log4j，所以必需把 spring-boot-starter-logging 排除掉
    compile.exclude module: &amp;quot;spring-boot-starter-logging&amp;quot;
}

dependencies {
    compile(&amp;quot;org.springframework.boot:spring-boot-starter-web&amp;quot;)
    // spring-boot-starter-actuator 提供 &amp;quot;監控 app 運作狀況&amp;quot; 功能
    compile(&amp;quot;org.springframework.boot:spring-boot-starter-actuator&amp;quot;)
    // 改用 log4j 不用預設的 logback
    compile(&amp;quot;org.springframework.boot:spring-boot-starter-log4j&amp;quot;)
    ...etc
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;範例解說如下&lt;br/&gt;1. 引用了 spring boot plugin 之後就可以利用它提供的各項專屬 task (e.g. bootRun, bootRepackage) 進行開發&lt;br/&gt;2. spring boot 預設的 log 是 logback，我把它換成了 log4j。因為所有 spring-boot-starter-* 的 pom 都相依於 spring-boot-starter-logging，spring-boot-starter-logging 又相依於 logback，所以要加上 &lt;code&gt;compile.exclude module: &amp;quot;spring-boot-starter-logging&amp;quot;&lt;/code&gt; 把所有 pom 裡的 spring-boot-starter-logging 相依都排除掉，不然程式裡的 log 會出現部份相依 logback 部份相依 log4j 的問題&lt;/p&gt;&lt;h3&gt;常用的 gradle 指令&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;gradle bootRun&lt;/code&gt;
  &lt;ul&gt;
    &lt;li&gt;Run the project with support for auto-detecting main class and reloading static resources&lt;/li&gt;
    &lt;li&gt;直接執行 compile 好的 class，不會打包成 war 或 jar&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;gradle bootRepackage&lt;/code&gt;
  &lt;ul&gt;
    &lt;li&gt;Repackage existing JAR and WAR archives so that they can be executed from the command line using &#39;java -jar&#39;&lt;/li&gt;
    &lt;li&gt;先把程式打包成 executable jar (or war)，然後再執行 jar (or war)&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;官方文件裡較重要相關章節&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#getting-started-gradle-installation&quot;&gt;10.1.2 Gradle installation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#using-boot-starter-poms&quot;&gt;13.4 Starter POMs&lt;/a&gt; : 有所有 starter pom 明細列表&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#using-boot-running-with-the-gradle-plugin&quot;&gt;19.4 Using the Gradle plugin&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#build-tool-plugins-including-the-gradle-plugin&quot;&gt;59.1 Including the plugin&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#build-tool-plugins-gradle-dependencies-without-versions&quot;&gt;59.2 Declaring dependencies without versions&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#build-tool-plugins-gradle-packaging&quot;&gt;59.4 Packaging executable jar and war files&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#build-tool-plugins-gradle-running-applications&quot;&gt;59.5 Running a project in-place&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;‘How-to’ guides&lt;/h2&gt;&lt;p&gt;官方文件有列出常見問題與解答，下列儿項是我目前比較會遇到的項目&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#howto-use-yaml-for-external-properties&quot;&gt;63.4 Use YAML for external properties&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#howto-add-a-servlet-filter-or-servletcontextlistener&quot;&gt;64.1 Add a Servlet, Filter or ServletContextListener to an application&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#howto-configure-ssl&quot;&gt;64.6 Configure SSL&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#howto-enable-multiple-connectors-in-tomcat&quot;&gt;64.8 Enable Multiple Connectors with Tomcat&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#howto-use-tomcat-behind-a-proxy-server&quot;&gt;64.9 Use Tomcat behind a front-end proxy server&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#howto-use-jetty-instead-of-tomcat&quot;&gt;64.10 Use Jetty instead of Tomcat&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#how-to-enable-http-response-compression-tomcat&quot;&gt;64.18.1 Enable Tomcat’s HTTP response compression&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#howto-write-an-xml-rest-service&quot;&gt;65.2 Write an XML REST service&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#howto-configure-log4j-for-logging&quot;&gt;66.2 Configure Log4j for logging&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#howto-two-datasources&quot;&gt;67.2 Configure Two DataSources&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#howto-customize-the-whitelabel-error-page&quot;&gt;70.2 Customize the ‘whitelabel’ error page&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#howto-enable-https&quot;&gt;71.3 Enable HTTPS when running behind a proxy server&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#howto-reload-thymeleaf-content&quot;&gt;72.2 Reload Thymeleaf templates without restarting the container&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/1.2.5.RELEASE/reference/htmlsingle/#howto-create-a-deployable-war-file&quot;&gt;74.1 Create a deployable war file&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>

    <item>
      <title>gradle learning path</title>
      <link>http://cloudtu.github.io/blog/2015/09/gradle-learning-path.html</link>
      <pubDate>星期四, 3 九月 2015 22:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/09/gradle-learning-path.html</guid>
      <description>&lt;p&gt;我用 gradle 當 build tool 已經好一陣子，通常照著網路上的 gradle 範例去修改就可以讓它滿足我的需求，真是超方便。可是對於 gradle script 為啥長這個樣子? 它的運作原理為何? 我一直搞不懂所以然。這次花了些時間終於了解它的基礎原理到底是怎麼回事。下述是我學習 gradle 基礎原理的 learning path，請照條列順序依序閱讀，看完後就可以對 gradle 知其然又知其所以然!&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;想要 gradle 快速上手? 看 popcorn 的 &quot;Gradle起步走(&lt;a href=&quot;http://www.slideshare.net/popcornylu/gradle-cli-application&quot;&gt;投影片&lt;/a&gt;、&lt;a href=&quot;https://www.youtube.com/watch?v=rWXspaS-pHI&quot;&gt;影片&lt;/a&gt;)&quot; 就對啦&lt;/li&gt;
  &lt;li&gt;對 gradle 有點 fu 之後就可以把 &lt;a href=&quot;https://www.manning.com/books/gradle-in-action&quot;&gt;grdle in action&lt;/a&gt; 這本書拿來看了。整本書分成三個 part，只要看 part1, part2 就夠了，part3 是比較進階的應用，未來有需要的話再來看&lt;/li&gt;
  &lt;li&gt;grdle in action 看完後可能會覺的對 gradle script 的 groovy 語法理解太少，這時必需看一些 groovy 語法說明，所以下面這些資料都看一看吧。
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.manning.com/books/gradle-in-action&quot;&gt;grdle in action&lt;/a&gt; 的 Appendix B 章節&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.vogella.com/tutorials/Groovy/article.html&quot;&gt;Groovy with Eclipse - Tutorial&lt;/a&gt; 的項次 1 ~ 14 內容&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/JustinSDK/groovy-gradle?ref=http://www.codedata.com.tw/java/groovy-gradle-abc/&quot;&gt;淺談 Groovy 與 Gradle&lt;/a&gt;。這份 slide 看完後對 groovy 的 closure 會有很清楚的理解，也終於知道 gradle script 語法用了大量的 closure&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;前面的都看完後就可以開始看下列講 gradle 運作原理的文章，看完後就會知道 gradle script 語法其實是 groovy closure 與 delegate pattern 的組合
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-1-ant/&quot;&gt;【認識 Gradle】（1）講古的時間 Apache Ant&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-2-maven/&quot;&gt;【認識 Gradle】（2）講古的時間 Apache Maven&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-3-getting-started/&quot;&gt;【認識 Gradle】（3）Gradle 起手式&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-4-gradle-script/&quot;&gt;【認識 Gradle】（4）看懂 Gradle Script&lt;/a&gt;。這份文件解釋了 gradle script 語法跟 groovy closure 、delegate pattern 的關聯性&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-3-gradle-task-abc/&quot;&gt;【認識 Gradle】（5）Gradle Task 觀念導讀&lt;/a&gt;。這份文件解釋了 gradle task 裡的 action closure、configure closure 是怎麼一回事。&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-4-java-project-build-script-customization/&quot;&gt;【認識 Gradle】（6）Java 專案與 Build Script 客製化&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-7-java-project-dependencies/&quot;&gt;認識 Gradle】（7）Java 專案相依管理&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/understanding-gradle-8-reuse-logic/&quot;&gt;【認識 Gradle】（8）邏輯重用&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;前述資料都看完後對於 gradle 官網的 &lt;a href=&quot;https://docs.gradle.org/current/userguide/userguide.html&quot;&gt;user guide &lt;/a&gt;、&lt;a href=&quot;https://docs.gradle.org/current/dsl/&quot;&gt;DSL Reference&lt;/a&gt;、&lt;a href=&quot;https://docs.gradle.org/current/javadoc/&quot;&gt;javadoc&lt;/a&gt; 應該就都看的懂，而不會在查閱時有摸不著頭緒的感覺了&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>

    <item>
      <title>java 8 lambda resource</title>
      <link>http://cloudtu.github.io/blog/2015/08/java-8-lambda-resource.html</link>
      <pubDate>星期四, 27 八月 2015 15:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/08/java-8-lambda-resource.html</guid>
      <description>&lt;p&gt;java 8 lambda 功能已經出來一年多，相關討論與資源也很多。不過這玩意兒如果太久沒用的話，總是把學到的又還回去。為了想複習時可以快速找到相關資源，還是把這些資訊筆記下來卡實在。以下是相關明細，有興趣的可以照條列順序依序閱讀。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;java 8 new api
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://ingramchen.io/blog/2014/04/java-8-new-api-tips.html&quot;&gt;Java 8 New API Tips&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;java 8 lambda
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/JustinSDK/12-lambda&quot;&gt;Java SE 8 技術手冊第 12 章 - Lambda&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/java/jdk8-functional-api/&quot;&gt;【演講稿】解析 JDK8 Functional API&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;monad design pattern
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.codedata.com.tw/social-coding/java8-patterns/&quot;&gt;【演講稿】Java 8 Patterns&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://ingramchen.io/blog/2014/11/monad-design-pattern-in-java.html&quot;&gt;Monad Design Pattern in Java&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>

    <item>
      <title>利用 jbake 從 blogger 搬家到 github</title>
      <link>http://cloudtu.github.io/blog/2015/08/migrate-from-blogger-to-jbake.html</link>
      <pubDate>星期二, 18 八月 2015 18:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/08/migrate-from-blogger-to-jbake.html</guid>
      <description>&lt;p&gt;打算搬離 &lt;a href=&quot;http://blogger.com&quot;&gt;blogger&lt;/a&gt; 的念頭很早就有了，只是一直沒有行動。主要原因還是打包整個站台的文章、圖片太麻煩，所以就一直沒動手。二週前開始有了段長時間的空檔，所以下定決心告別 blogger，自己蓋個新 blog 站台。&lt;/p&gt;&lt;h2&gt;為何搬離 blogger&lt;/h2&gt;&lt;p&gt;沒事 blogger 用的好好的為何會想搬家呢? 原因大略是下述儿點&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;不易撰寫技術文章。blogger 上面寫一般生活記事很容易，但是寫程式開發技術文就不是這麼回事了，要讓美美的程式碼秀出正常樣子實在太累人。&lt;/li&gt;
  &lt;li&gt;發佈文章前的文章檢視功能跑起來超慢。這可能跟我在 blogger 上插了很多外掛模組有關，但是這些模組我都會用到呀不能拿掉，所以這問題無解 囧rz&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;選擇新家&lt;/h2&gt;&lt;p&gt;既然要搬家了，那新家要怎麼選呢? 我決定 &lt;code&gt;自己的 blog 自己蓋&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;ingram 的 &lt;a href=&quot;http://ingramchen.io/blog/2014/01/move-to-new-home-again.html&quot;&gt;新年搬新家- Jbake&lt;/a&gt; 裡提到 &lt;code&gt;任何 Hosting Service 最終都會消失&lt;/code&gt; 是非常中肯的見解。雖然不見得一定會消失，但是未來的事實在太難說。現在寫 blog 早就不潮了，但是寫了十多年累積的 400 多篇文章說什麼也不能隨著搬家歸零重來。為了避免未來一而再再而三的搬家，還是自己蓋 blog 吧!&lt;/p&gt;&lt;h2&gt;新 blog 怎麼搭建?&lt;/h2&gt;&lt;p&gt;既然要自己土砲了，那當然是找目前市面上 &lt;code&gt;static site generator&lt;/code&gt; 產品有哪些。 &lt;a href=&quot;https://www.staticgen.com/&quot;&gt;StaticGen&lt;/a&gt; 上看到的統計報表裡，最熱門的產品是 &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt;，不過我是 java guy 所以我選 &lt;a href=&quot;http://jbake.org&quot;&gt;jbake&lt;/a&gt; 這個 java solution。&lt;/p&gt;&lt;p&gt;下列儿項 jbake 產品特性是我選它的原因&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;完整的&lt;a href=&quot;http://www.jbake.org/docs/2.4.0/&quot;&gt;說明書&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;多人維護的&lt;a href=&quot;https://github.com/jbake-org/jbake&quot;&gt;專案&lt;/a&gt;，不用擔心突然被放生。&lt;/li&gt;
  &lt;li&gt;blog 文章支援 &lt;code&gt;markdown&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt; 格式。html 格式就不用說了，算是舊時代的遺物，一定會支援。寫新文章的話，如果不是文章格式很複雜，我是一定會選擇 markdown 格式，可以省時又省力。&lt;/li&gt;
  &lt;li&gt;內建 &lt;code&gt;jetty&lt;/code&gt;，文章寫完後可以馬上在 local 跑起來看看結果正不正確，不需丟到 remote 才能進行驗証&lt;/li&gt;
  &lt;li&gt;文章裡貼的程式碼可以用 &lt;code&gt;pretty print&lt;/code&gt; 風格來呈現。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;jbake 快速上手&lt;/h2&gt;&lt;p&gt;下載 &lt;a href=&quot;http://www.jbake.org/download.html&quot;&gt;jbake&lt;/a&gt; 進行安裝。目前 v2.4.0 最新版有個&lt;a href=&quot;https://github.com/jbake-org/jbake/issues/226&quot;&gt;嚴重的 bug&lt;/a&gt;，每次 site gen 時一定會全部資料重建，沒辦法進行 incremental render，建議安裝 v2.3.2 版。&lt;/p&gt;&lt;p&gt;jbake v2.3.2 常用指令沒儿個，搞懂它吧!&lt;/p&gt;
&lt;!--?prettify?--&gt;
&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;# init jbake project
jbake -i
jbake -i &amp;lt;freemarker|groovy|thymeleaf&amp;gt;

# site gen
jbake -b
jbake -b &amp;lt;source&amp;gt; &amp;lt;output&amp;gt;

# start local server
jbake -s
jbake -s &amp;lt;directory&amp;gt;

# site gen &amp;amp; start local server
jbake -b -s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;http://www.jbake.org/docs/2.4.0/&quot;&gt;官方文件&lt;/a&gt;不長而且很完整，建議看過一遍。&lt;/p&gt;&lt;h2&gt;jbake.properties 設定檔說明&lt;/h2&gt;&lt;p&gt;其中比較需要特別說明的是 &lt;code&gt;db.store=local&lt;/code&gt;，設成這值代表每次 jbake 只會針對異動(新增或修改)的文章進行 site gen，不會全部的文章都進行 site gen，這是一個很有用的功能!&lt;/p&gt;
&lt;!--?prettify?--&gt;
&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;# defines the host URL for the site
site.host={my_blog_site_url}

# render index file?
render.index=true
# render archive file?
render.archive=true
# render feed file?
render.feed=true
# render tag files?
render.tags=true
# render sitemap.xml file?
render.sitemap=true

# filename of index template file
template.index.file=index.thyme
# filename of archive template file
template.archive.file=archive.thyme
# filename of tag template file
template.tag.file=tags.thyme
# filename of sitemap template file
template.sitemap.file=sitemap.thyme
# filename of post template file
template.post.file=post.thyme
# filename of page template file
template.page.file=page.thyme
# filename of feed template file
template.feed.file=feed.thyme

# default date format used in content files
date.format=yyyy-MM-dd

# database store (local, memory)
# This option defines whether the content store built while parsing your content files is persisted to disk or not.When it is persisted to disk the next time you perform a bake only those content files that have changed will be rendered speeding up the process. When it is not persisted to disk, i.e. kept in memory, a full bake of all content is performed every time.
db.store=local
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;撰寫 markdown 文件的注意事項&lt;/h2&gt;&lt;p&gt;文章如果出現 &lt;code&gt;包了太多層的條列式項目&lt;/code&gt; 可能會導致 site gen 後的 html 出現排版亂掉的問題，撰寫文章時要迴避這問題。&lt;/p&gt;&lt;h2&gt;markdown 文件如何插入圖片?&lt;/h2&gt;&lt;p&gt;只是單純的文章插入圖片可以直接用 markdown 語法&lt;/p&gt;
&lt;!--?prettify?--&gt;
&lt;pre&gt;&lt;code&gt;![imageName](imageFileUrl)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果要有 &lt;code&gt;點擊縮圖時開啟原始大圖&lt;/code&gt; 效果，必需用 html 語法&lt;/p&gt;
&lt;!--?prettify?--&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;a href=&amp;quot;/img/{myImage.jpg}&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;
    &amp;lt;img src=&amp;quot;/img/{myImage.jpg}&amp;quot; width=&amp;quot;{width}&amp;quot; /&amp;gt;
&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;markdown 文件如何插入程式碼?&lt;/h2&gt;&lt;p&gt;可以用 markdown 或 html 語法，個人推薦用 markdown 語法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# markdown 格式
&amp;lt;!--?prettify linenums=true?--&amp;gt;
```java
public class CloudTu {
  public static void main(String[] args) {
    System.out.print(&amp;quot;hello world!&amp;quot;);
  }
}
```
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;# html 格式
&amp;lt;pre class=&amp;quot;prettyprint linenums&amp;quot;&amp;gt;
public class CloudTu {
  public static void main(String[] args) {
    System.out.print(&amp;quot;hello world!&amp;quot;);
  }
}
&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;site gen 結果像下面這樣，程式碼帶有行號而且是 pretty print 風格&lt;/p&gt;
&lt;!--?prettify linenums=true?--&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class CloudTu {
  public static void main(String[] args) {
    System.out.print(&amp;quot;hello world!&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果不想帶行號的話則是把 &lt;code&gt;linenums&lt;/code&gt; 拿掉&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# markdown 格式
&amp;lt;!--?prettify?--&amp;gt;
my code...etc
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;# html 格式
&amp;lt;pre class=&amp;quot;prettyprint&amp;quot;&amp;gt;
    my code...etc
&amp;lt;pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;新 blog 要放在哪?&lt;/h2&gt;&lt;p&gt;任何可以放 static site 的雲端空間都可以當存放站台，我自己的選擇是放在 github。原因的話有二個&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;static site 放 github &lt;strike&gt;正潮&lt;/strike&gt;不用錢&lt;/li&gt;
  &lt;li&gt;github 的網路頻寬夠大，連過去速度夠快&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在 github 上建立 static site 的&lt;a href=&quot;https://pages.github.com/&quot;&gt;方法&lt;/a&gt;很簡單，分成二種方式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;第一種是在 github 上建立 &lt;code&gt;{myAccount}.github.io&lt;/code&gt; 的 repository，接著把 static site 推上去，然後連到 &lt;code&gt;http://{myAccount}.github.io&lt;/code&gt; 就可以看到建立的站台&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;第二種則是在 github 現有的 &lt;code&gt;{myProject}&lt;/code&gt; repository 建立 &lt;code&gt;gh-pages&lt;/code&gt; branch，接著把 static site 推上去，然後連到 &lt;code&gt;http://{myAccount}.github.io/{myProject}&lt;/code&gt; 就可以看到建立的站台&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;舊資料要怎麼搬過去?&lt;/h2&gt;&lt;p&gt;搬舊資料沒啥現成工具可用，只好自己寫工具。我利用 &lt;a href=&quot;http://jsoup.org/&quot;&gt;jsoup&lt;/a&gt;, &lt;a href=&quot;https://github.com/rometools/rome&quot;&gt;rome&lt;/a&gt; lib 寫了 &lt;a href=&quot;https://github.com/cloudtu/blogger-to-jbake&quot;&gt;blogger-to-jbake&lt;br/&gt;&lt;/a&gt; 這個專門從 blogger 搬家到 jbake 的搬遷工具。它可以把放在 blogger 裡的個人文章、圖片全部匯出至本地端，並且轉成 jbake 可以匯入的檔案格式。&lt;/p&gt;&lt;h2&gt;後記&lt;/h2&gt;&lt;p&gt;其實 blog 搬家很辛苦，自建 static blog site 就更辛苦了，但是相對的獲益也非常巨大。什麼都自己來代表什麼都掌控在手中，未來如果發生任何狀況都可以自己應付，也不會遇到 vendor 倒了就全部資料人間蒸發的鳥事。記得以前無名小站倒了時網路上哀聲遍野，未來收掉的 blog service 只會更多不會更少，長遠考量下還是自己的 blog 自己蓋比較實際呀~~~&lt;/p&gt;</description>
    </item>

    <item>
      <title>java library for github api 心得筆記</title>
      <link>http://cloudtu.github.io/blog/2015/07/java-library-for-github-api.html</link>
      <pubDate>星期五, 3 七月 2015 13:34:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/07/java-library-for-github-api.html</guid>
      <description>
這陣子用 java 去呼叫 github restful api 之後有些心得，將它做個簡單記錄
&lt;br&gt;
&lt;ul&gt;
 &lt;li&gt;github api v3 說明文件在&lt;a href=&quot;https://developer.github.com/v3/&quot; target=&quot;_blank&quot;&gt;這裡&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;github 推薦的 java library 有&lt;a href=&quot;https://developer.github.com/libraries/&quot; target=&quot;_blank&quot;&gt;下列三個&lt;/a&gt;&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;&lt;a href=&quot;https://github.com/eclipse/egit-github/tree/master/org.eclipse.egit.github.core&quot; target=&quot;_blank&quot;&gt;egit-github&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;https://github.com/kohsuke/github-api&quot; target=&quot;_blank&quot;&gt;kohsuke-github-api&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;https://github.com/jcabi/jcabi-github&quot; target=&quot;_blank&quot;&gt;jcabi-github&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;java library 對 github api v3 支援度&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;kohsuke-github-api &amp;gt; jcabi-github &amp;gt; egit-github&lt;/li&gt;
   &lt;li&gt;kohsuke-github-api 實作最完整&lt;/li&gt;
   &lt;li&gt;jcabi-github 缺少很多實作&lt;/li&gt;
   &lt;li&gt;egit-github 的目標是 100% 支援 github api v3，可是 source code 裡反而還存留一堆呼叫 github legacy api 的 code&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;java library 操作便捷性&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt; jcabi-github &amp;gt; kohsuke-github-api &amp;gt; egit-github&lt;/li&gt;
   &lt;li&gt;kohsuke-github-api 與 jcabi-github 在操作上比 egit-github 好很多，egit-github 這方面顯的過時&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;java library 說明文件完整度&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;三者都很爛，沒啥文件說明。要查怎麼使用要去看 source code 裡 junit test 相關 class&lt;/li&gt;
   &lt;li&gt;因為 egit-github 出來時間最早，所以 &lt;a href=&quot;http://stackoverflow.com/&quot; target=&quot;_blank&quot;&gt;stackoverflow&lt;/a&gt; 裡比較能找到 egit-github 相關問題的解答&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;總結&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;以現況而言，個人推薦使用 kohsuke-github-api。它對 github api v3 支援最完整，在 libray 操作上也蠻直覺的&lt;/li&gt;
   &lt;li&gt;如果不介意 library 是否用到 github api v3，而是要找白老鼠最多的 library，那選 egit-github 就對了。它最早出來，所以功能最完整，白老鼠最多&lt;/li&gt;
   &lt;li&gt;從設計角度來看，jcabi-github 設計最好。但是因為它太年輕，欠缺很多功能&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;https://developer.github.com/v3/search/&quot; target=&quot;_blank&quot;&gt;github search api&lt;/a&gt; 有 bug，我遇過查詢條件正確，但是查詢結果是錯誤的狀況。如果用 java library 去呼叫 github api 卻發現結果總是錯的，這時除了要懷疑 library 本身有 bug 之外，最好要用 restful client 去驗証 github api 是不是一開始就回傳錯誤資料 &lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

  </channel>
</rss>
