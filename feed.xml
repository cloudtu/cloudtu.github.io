<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>老涂的咁仔店</title>
    <link>http://cloudtu.github.io</link>
    <atom:link href="http://cloudtu.github.io/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <description>老涂的咁仔店</description>
    <language>zh-TW</language>
    <pubDate>Fri, 14 Aug 2015 22:19:23 +0800</pubDate>
    <lastBuildDate>Fri, 14 Aug 2015 22:19:23 +0800</lastBuildDate>

    <item>
      <title>java library for github api 心得筆記</title>
      <link>http://cloudtu.github.io/blog/2015/07/java-library-for-github-api.html</link>
      <pubDate>Fri, 3 Jul 2015 13:34:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/07/java-library-for-github-api.html</guid>
      <description>
這陣子用 java 去呼叫 github restful api 之後有些心得，將它做個簡單記錄
&lt;br&gt;
&lt;ul&gt;
 &lt;li&gt;github api v3 說明文件在&lt;a href=&quot;https://developer.github.com/v3/&quot; target=&quot;_blank&quot;&gt;這裡&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;github 推薦的 java library 有&lt;a href=&quot;https://developer.github.com/libraries/&quot; target=&quot;_blank&quot;&gt;下列三個&lt;/a&gt;&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;&lt;a href=&quot;https://github.com/eclipse/egit-github/tree/master/org.eclipse.egit.github.core&quot; target=&quot;_blank&quot;&gt;egit-github&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;https://github.com/kohsuke/github-api&quot; target=&quot;_blank&quot;&gt;kohsuke-github-api&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;https://github.com/jcabi/jcabi-github&quot; target=&quot;_blank&quot;&gt;jcabi-github&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;java library 對 github api v3 支援度&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;kohsuke-github-api &amp;gt; jcabi-github &amp;gt; egit-github&lt;/li&gt;
   &lt;li&gt;kohsuke-github-api 實作最完整&lt;/li&gt;
   &lt;li&gt;jcabi-github 缺少很多實作&lt;/li&gt;
   &lt;li&gt;egit-github 的目標是 100% 支援 github api v3，可是 source code 裡反而還存留一堆呼叫 github legacy api 的 code&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;java library 操作便捷性&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt; jcabi-github &amp;gt; kohsuke-github-api &amp;gt; egit-github&lt;/li&gt;
   &lt;li&gt;kohsuke-github-api 與 jcabi-github 在操作上比 egit-github 好很多，egit-github 這方面顯的過時&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;java library 說明文件完整度&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;三者都很爛，沒啥文件說明。要查怎麼使用要去看 source code 裡 junit test 相關 class&lt;/li&gt;
   &lt;li&gt;因為 egit-github 出來時間最早，所以 &lt;a href=&quot;http://stackoverflow.com/&quot; target=&quot;_blank&quot;&gt;stackoverflow&lt;/a&gt; 裡比較能找到 egit-github 相關問題的解答&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;總結&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;以現況而言，個人推薦使用 kohsuke-github-api。它對 github api v3 支援最完整，在 libray 操作上也蠻直覺的&lt;/li&gt;
   &lt;li&gt;如果不介意 library 是否用到 github api v3，而是要找白老鼠最多的 library，那選 egit-github 就對了。它最早出來，所以功能最完整，白老鼠最多&lt;/li&gt;
   &lt;li&gt;從設計角度來看，jcabi-github 設計最好。但是因為它太年輕，欠缺很多功能&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;https://developer.github.com/v3/search/&quot; target=&quot;_blank&quot;&gt;github search api&lt;/a&gt; 有 bug，我遇過查詢條件正確，但是查詢結果是錯誤的狀況。如果用 java library 去呼叫 github api 卻發現結果總是錯的，這時除了要懷疑 library 本身有 bug 之外，最好要用 restful client 去驗証 github api 是不是一開始就回傳錯誤資料 &lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>

    <item>
      <title>用 https 連線到 github 進行 push(或 pull) 時，略過每次都要打帳密的動作</title>
      <link>http://cloudtu.github.io/blog/2015/02/https-github-push-pull.html</link>
      <pubDate>Thu, 26 Feb 2015 16:57:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/02/https-github-push-pull.html</guid>
      <description>
當 local repository 用 https 連線至 github 進行 push(或 pull) 時，總是都要打一次帳號與密碼。頻繁進行 push(或 pull) 時，打帳密的動作就變的很惱人。雖然說用 ssh 連線就可免掉這問題，不過在使用 https 的前題下，這問題也是有解法。
&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 
&lt;br&gt;首先，先確定 git 版本大於等於 1.7.9。如果是 windows 使用者，請先安裝 TortoiseGit(版本必需大於等於 1.8.1.2)。
&lt;br&gt;
&lt;br&gt;以下範例用 TortoiseGit 進行操作
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;確認 &quot;Credential helper&quot; 選到 &quot;wincred - this repository only&quot;。&lt;br&gt;&lt;a href=&quot;../../../img/2015/02/201502261657_1.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;../../../img/2015/02/201502261657_1.png&quot; height=&quot;183&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;進行修改後的第一次 push(或 pull)，這時會出現輸入帳密的指示，照著指示輸入完成。以後進行 push(或 pull) 時不會再問你帳密了。&lt;/li&gt;
 &lt;li&gt;開啟 &quot;我的電腦&quot;，輸入 &quot;控制台\使用者帳戶和家庭安全\認證管理員&quot;，這時會發現多一組 github 專用的憑証。以後你若改過 github 上的密碼，記的要來這裡修改憑証內的資料，不然在你執行 push(或 pull) 時會發生無法登入 github 的狀況。&lt;br&gt;&lt;a href=&quot;../../../img/2015/02/201502261657_2.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;../../../img/2015/02/201502261657_2.png&quot; height=&quot;332&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;網路上面相關參考資料如下，linux、mac 使用者可參考這些資料來處理上述文章所提的問題。 
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/a/5343146/779564&quot; target=&quot;_blank&quot;&gt;Is there a way to skip password typing when using https:// github&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/a/15351702/779564&quot; target=&quot;_blank&quot;&gt;TortoiseGit save user authentication / credentials&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/a/15382950/779564&quot; target=&quot;_blank&quot;&gt;remove credentials from git&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>

    <item>
      <title>如何備份 github 各別 project 所有 branch 到本地端，並將該專案搬移至 bitbucket</title>
      <link>http://cloudtu.github.io/blog/2015/02/github-project-branch-bitbucket.html</link>
      <pubDate>Thu, 26 Feb 2015 14:34:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015/02/github-project-branch-bitbucket.html</guid>
      <description>
執行 &quot;git clone&quot; 無法將 github 各別 project 的所有 remote branch 都在 local repository 產生一份，只會在 local 產生 master branch。這時如果要將 local repository push 到(或說是搬到) new remote repository 會發生很大的問題。當你在 local repository 執行完 &quot;git push --all&quot; 後會發現 remote repository 只存在 master branch，其它 branch 不會出現在裡面。
&lt;br&gt;
&lt;br&gt;當然!你可以在執行完 &quot;git clone&quot; 後，接著執行 &quot;git checkout&quot; 將 remote branch 在 local repository 裡手動一個個建出來。不過這種傻事還是少幹的好，如果 remote branch 有好儿十個，手工建立對應的 local branch 可能會讓你哭爹喴娘。這時當然要用有效率的招式才行!!!
&lt;br&gt;
&lt;br&gt;先寫出備份 github project 專用的備份 script。我把它命名為 github_project_backup.sh
&lt;br&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;#github_project_backup.sh&lt;br&gt;#!/bin/sh&lt;br&gt;&lt;br&gt;#執行前要先修改這裡，設定你的 github id&lt;br&gt;github_user_id=my_github_id&lt;br&gt;&lt;br&gt;#執行前要先修改這裡，設定你的 github password&lt;br&gt;github_user_pwd=my_github_pwd&lt;br&gt;&lt;br&gt;#執行這個 bash 時，在 console 要輸入的 github project name&lt;br&gt;read -p &quot;input the name of github project : &quot; github_project_name&lt;br&gt;&lt;br&gt;#在 local 端產生 bare repository，並將 remote 端的每個 branch 都在 local 端產生一份&lt;br&gt;#&lt;br&gt;# --mirror 參數的官方說明如下&lt;br&gt;# Set up a mirror of the source repository. This implies --bare. Compared to --bare, --mirror not only &lt;br&gt;# maps local branches of the source to local branches of the target, it maps all refs (including &lt;br&gt;# remote-tracking branches, notes etc.) and sets up a refspec configuration such that all these refs &lt;br&gt;# are overwritten by a git remote update in the target repository.&lt;br&gt;#&lt;br&gt;git clone --mirror https://${github_user_id}:${github_user_pwd}@github.com/${github_user_id}/${github_project_name}.git&lt;br&gt;&lt;br&gt;cd ${github_project_name}.git&lt;br&gt;&lt;br&gt;#因為 remote repository 在你備份到 local 端之後可能會刪除，所以先把 remote 來源刪掉&lt;br&gt;git remote rm origin&lt;br&gt;&lt;br&gt;cd ..&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;進行備份，流程像下述這樣
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;remote repository 有二個 branch、二個 tag&lt;br&gt;&lt;a href=&quot;../../../img/2015/02/201502261434_1.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;../../../img/2015/02/201502261434_1.png&quot; height=&quot;218&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;輸入 github 裡的 project name&lt;br&gt;&lt;a href=&quot;../../../img/2015/02/201502261434_2.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;../../../img/2015/02/201502261434_2.png&quot; height=&quot;157&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;github_project_backup.bash 執行完畢後，產生 local bare repository，而且裡面有二個 local branch、二個 local tag&lt;br&gt;&lt;a href=&quot;../../../img/2015/02/201502261434_3.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;../../../img/2015/02/201502261434_3.png&quot; height=&quot;400&quot; width=&quot;377&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;如果只打算把 github 的 project 在刪除前先備份到本地端後再刪除，到這步驟就算完成了。之後可以視需求再把備分下來的 local bare repository 進行 zip 或是 tgz 後丟到雲端(e.g. AWS S3,dropbox...etc)進行封存。
&lt;br&gt;
&lt;br&gt;如果是打算把 local repository push 到(或說是搬到) new remote repository，接下來要執行下列指令。
&lt;br&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;cd /path/to/my_local_repository&lt;br&gt;git remote add origin https://my_new_remote_repository&lt;br&gt;git push -u origin --all #pushes up the repo and its refs for the first time &lt;br&gt;git push -u origin --tags #pushes up any tags&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;接續的搬移流程像下述這樣
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;new remote repository 指到 bitbucket&lt;br&gt;&lt;a href=&quot;../../../img/2015/02/201502261434_4.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;../../../img/2015/02/201502261434_4.png&quot; height=&quot;246&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;搬完後 bitbucket 裡的 remote repository 有二個 branch、二個 tag，跟當初放在 github 裡的一樣&lt;br&gt;&lt;a href=&quot;../../../img/2015/02/201502261434_5.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;../../../img/2015/02/201502261434_5.png&quot; height=&quot;153&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;至此就完成了從 github 搬到 bitbucket 的動作。
&lt;br&gt;
&lt;br&gt;你說何時有機會用到這篇文章的招式?如果你在 github 上面開了太多 private repository，超過單一付費帳號許可的最大上限(目前 github 最多只能開 50 個 private repository)，這招就用的上了...XDDD
</description>
    </item>

    <item>
      <title>OAuth2 心得筆記</title>
      <link>http://cloudtu.github.io/blog/2014/12/oauth2.html</link>
      <pubDate>Sun, 7 Dec 2014 20:07:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2014/12/oauth2.html</guid>
      <description>
這陣子因為工作上需要，必需了解 OAuth2 原理。在網路上查了一陣子後發現下面這份解說詳盡的投影片，有興趣的人可以參考一下...:)
&lt;br&gt;
&lt;br&gt;簡單易懂的 OAuth 2.0 (
&lt;a href=&quot;https://speakerdeck.com/chitsaou/jian-dan-yi-dong-de-oauth-2-dot-0&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;) (
&lt;a href=&quot;https://www.youtube.com/watch?v=tMG-kl_uohY&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;) 
&lt;br&gt;
&lt;br&gt;我沒有實作 OAuth2 的需求，但是有使用 OAuth2 的需求，必需對它裡面的認証、授權機制有通盤了解。投影片裡跟 OAuth2 認証、授權相關的資料節錄如下，並做摘要說明。
&lt;br&gt;
&lt;br&gt;======================================================================
&lt;br&gt;OAuth2 裡的 Role
&lt;br&gt;
&lt;br&gt;
&lt;a href=&quot;../../../img/2014/12/201412072007_1.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;../../../img/2014/12/201412072007_1.png&quot; height=&quot;218&quot; width=&quot;400&quot;&gt;&lt;/a&gt;
&lt;br&gt;
&lt;ul&gt;
 &lt;li&gt;Authorization Server&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;「Authorization Server」發出去的授權碼有二種，分別是「Grant Code」、「Token」&lt;/li&gt;
   &lt;li&gt;&amp;nbsp;「Resource Owner」同意「Client」存取「Resource Owner」的資料時，「Authorization Server」發「Grant Code」給「Client」&lt;/li&gt;
   &lt;li&gt;「Client」可以拿「Grant Code」跟「Authorization Server」換「Token」 &lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;Resource Server&lt;br&gt;
  &lt;ul&gt;
   &lt;li&gt;「Resource Server」的存取認証是認「Token」不是認「Grant Code」&lt;/li&gt;
   &lt;li&gt;用「Token」跟「Resource Server」進行認証，認証成功後可以存取「Resource Owner」的資料 &lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;======================================================================
&lt;br&gt;OAuth2 授權流程
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;Authorization Code Grant Flow&lt;br&gt;&lt;a href=&quot;../../../img/2014/12/201412072007_2.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;../../../img/2014/12/201412072007_2.png&quot; height=&quot;208&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;br&gt;先跟「Authorization Server」要「Grant Code」，接著再用「Grant Code」去跟「Authorization Server」換「Token」&lt;/li&gt;
 &lt;li&gt;Implicit Grant Flow&lt;br&gt;&lt;a href=&quot;../../../img/2014/12/201412072007_3.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;../../../img/2014/12/201412072007_3.png&quot; height=&quot;277&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;br&gt;直接跟「Authorization Server」要「Token」，沒有「Grant Code」換「Token」的步驟&lt;/li&gt;
 &lt;li&gt;Resource Owner Password Credentials Grant Flow&lt;br&gt;&lt;a href=&quot;../../../img/2014/12/201412072007_4.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;../../../img/2014/12/201412072007_4.png&quot; height=&quot;233&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;br&gt;拿「Resource Owner」的 username、password 去跟「Authorization Server」要「Token」&lt;/li&gt;
 &lt;li&gt;Client Credentials Grant Flow &lt;br&gt;&lt;a href=&quot;../../../img/2014/12/201412072007_5.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;../../../img/2014/12/201412072007_5.png&quot; height=&quot;195&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;br&gt;「Authorization Server」不需經由認証就直接給「Token」&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>

    <item>
      <title>Cassandra Summit 2014 心得筆記</title>
      <link>http://cloudtu.github.io/blog/2014/10/cassandra-summit-2014.html</link>
      <pubDate>Wed, 1 Oct 2014 20:43:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2014/10/cassandra-summit-2014.html</guid>
      <description>
Datastax 把前陣子辦的 Cassandra Summit 2014 
&lt;a href=&quot;http://www.slideshare.net/planetcassandra/tag/cassandra-summit-2014&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;、
&lt;a href=&quot;http://www.youtube.com/playlist?list=PLqcm6qE9lgKJkxYZUOIykswDndrOItnn2&quot; target=&quot;_blank&quot;&gt;視訊影片&lt;/a&gt;公開出來了，把這堆資料大略看完後針對比較重要的儿份摘要如下 ... :) 
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;C* 2.1 新功能簡介&lt;br&gt; Real Data Models of Silicon Valley(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-real-data-models-of-silicon-valley&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=XGrJLZcRhAw&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)&lt;br&gt; &lt;/li&gt;
 &lt;li&gt;C* 2.1 的設定檔多了哪些重要參數&lt;br&gt; Lesser Known Features of Cassandra 2.1(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-lesser-known-features-of-cassandra-21&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=ppZfB2tCrEs&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)&lt;br&gt; &lt;/li&gt;
 &lt;li&gt;CQL3 在 C* 2.1 &amp;amp; 2.0 的語法為何? CQL3 查詢顯示結果跟實際的 ColumFamily 是怎麼對照?&lt;br&gt; CQL Under the Hood(&lt;a href=&quot;http://www.slideshare.net/rastrick/cql-under-the-hood-39023557&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?list=PLqcm6qE9lgKJkxYZUOIykswDndrOItnn2&amp;amp;v=CY5-bWpqAVA&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)&lt;br&gt; Understanding CQL3 Inside and Out(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-understanding-cql3-inside-and-out&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=XoUqfq54xuA&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)&lt;br&gt; &lt;/li&gt;
 &lt;li&gt;扮演 admin 角色負責管理維運&lt;br&gt; Monitor Everything!(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-monitor-everything&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=RhUoQPHNA1Y&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)，裡面有提到 nodetool 監控指令參數(page 27~69)，JVM GC log 參數設定(page 74~78)&lt;br&gt; &lt;/li&gt;
 &lt;li&gt;校能調教&lt;br&gt; Performance Tuning Cassandra in AWS(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-39501315&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=Qfzg7gcSK-g&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)&lt;br&gt; &lt;/li&gt;
 &lt;li&gt;Spark 與 C* 整合應用現況&lt;br&gt; Apache Spark - The SDK for All Big Data Platforms(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-apache-spark-the-sdk-for-all-big-data-platforms&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=Ot-nrOaJHLE&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)&lt;br&gt; &lt;/li&gt;
 &lt;li&gt;一些大公司在使用 C* 後分享的經驗談
  &lt;strike&gt;
   (血淚控訴)
  &lt;/strike&gt;&lt;br&gt; Apache Cassandra Best Practices at Ebay(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-39677149&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=gn4MDRmrfKo&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)，從 page 7 開始是經驗談&lt;br&gt; Launching PlayStation 4 with Apache Cassandra(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-launching-playstation-4-with-apache-cassandra&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=FwMWvhyEgmg&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)，從 page 36 開始是經驗談&lt;br&gt; Cassandra at Instagram 2014(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-cassandra-at-instagram-2014&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=_gc94ITUitY&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)，從 page 55 開始是經驗談 &lt;br&gt; Interactive OLAP Queries using Apache Cassandra and Spark(&lt;a href=&quot;http://www.slideshare.net/planetcassandra/cassandra-summit-2014-interactive-olap-queries-using-apache-cassandra-and-spark&quot; target=&quot;_blank&quot;&gt;投影片&lt;/a&gt;)(&lt;a href=&quot;https://www.youtube.com/watch?v=zke8mp-kMMo&quot; target=&quot;_blank&quot;&gt;錄影&lt;/a&gt;)，講 Cassandra 與 Spark 整合使用的經驗&lt;br&gt; &lt;/li&gt;
&lt;/ol&gt;針對 C* 2.1 在 CQL 語法上提供的新功能，我個人不建議使用，因為有下述問題存在。這部份也提供給大家參考一下 
&lt;br&gt;
&lt;ul&gt;
 &lt;li&gt;UDT(User Defined Types) 功能還不成熟，未來的版本可能變動很大?&lt;/li&gt;
 &lt;li&gt;雖然改善了 counter 效能，不過我猜想它可能又無法向下相容舊版? 還是不要用counter 型別為妙&lt;/li&gt;
 &lt;li&gt;在 C* 2.1 有些語法宣告要加 frozen 這關鍵字，可是未來 C* 3.x 會把這關鍵字拿掉，未來版本八成無法向下相容這個宣告。為了個人身心健康，有這類宣告的功能就別用了吧&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>

    <item>
      <title>雲端 IaaS 主機建立 cassandra node 的注意事項</title>
      <link>http://cloudtu.github.io/blog/2014/09/iaas-cassandra-node.html</link>
      <pubDate>Tue, 23 Sep 2014 16:38:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2014/09/iaas-cassandra-node.html</guid>
      <description>
要在雲端 IaaS 主機建立 cassandra node，cassandra 設定檔裡跟 ip 有關的參數設定要特別留心，不然在 node 建完後會啟動失敗。這篇設定在&amp;nbsp; cassandra 1.x、2.x 都適用，有需要的可以參考一下...:)
&lt;br&gt;
&lt;br&gt;假設我在 AWS 建了一台 EC2，並且將它綁定 EIP(Elastic IP)，EC2 的 ip 資訊如下
&lt;br&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;private ip : 172.30.45.70&lt;br&gt;public ip : 50.190.20.220&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;目前的 cassandra ring(cluster) 分佈在多個 AWS region，seed node 的 public ip 是 60.190.20.210。我要將該台 EC2 加入其中，相關注意事項如下 
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;cassandra.yaml&lt;br&gt;設定值要長像這樣，相關原因在官方文件有&lt;a href=&quot;http://www.datastax.com/documentation/cassandra/2.1/cassandra/architecture/architectureSnitchEC2MultiRegion_c.html?scroll=concept_ds_gck_hrf_fk__other-settings&quot; target=&quot;_blank&quot;&gt;說明&lt;/a&gt;&lt;br&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;endpoint_snitch: EC2MultiRegionSnitch&lt;br&gt;listen_address : ec2_private_ip&lt;br&gt;rpc_address : ec2_private_ip&lt;br&gt;broadcast_address : ec2_public_ip&lt;br&gt;seeds : seed_public_ip&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;以目前的例子來說則是設成 &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;endpoint_snitch: EC2MultiRegionSnitch&lt;br&gt;listen_address : 172.30.45.70&lt;br&gt;rpc_address : 172.30.45.70&lt;br&gt;broadcast_address : 50.190.20.220&lt;br&gt;seeds : 60.190.20.210&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
 &lt;li&gt;cassandra-env.sh&lt;br&gt;增加下面這行跟 JMX 有關的設定。為何要加這行? 這是為了防止&amp;nbsp; nodetool 指令執行時出現 &quot;Connection has timed out&quot; 異常。這問題在 &lt;a href=&quot;http://stackoverflow.com/questions/15299302/cassandra-nodetool-connection-timed-out&quot; target=&quot;_blank&quot;&gt;stackoverflow &lt;/a&gt;有被討論跟解釋過。&lt;br&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;JVM_OPTS=&quot;$JVM_OPTS -Djava.rmi.server.hostname=127.0.0.1&quot;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
 &lt;li&gt;EC2 的 firewall 把該開的 port 都打開(從 EC2 &amp;gt; Security Group &amp;gt; Inbound 設定裡改)，一般來說是開啟下面儿個 &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;storage_port : 7000&lt;br&gt;jmx_port : 7199&lt;br&gt;native_transport_port : 9042&lt;br&gt;rpc_port : 9160&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;雖然這裡是用 EC2 當例子，不過只要是 IaaS 設定上應該都與此相似。比較大的差異在 cassandra.yaml 裡的 
&lt;a href=&quot;http://www.datastax.com/documentation/cassandra/2.1/cassandra/architecture/architectureSnitchesAbout_c.html&quot; target=&quot;_blank&quot;&gt;endpoint_snitch&lt;/a&gt; 設定，EC2 用 
&lt;a href=&quot;http://www.datastax.com/documentation/cassandra/2.1/cassandra/architecture/architectureSnitchEC2MultiRegion_c.html&quot; target=&quot;_blank&quot;&gt;EC2MultiRegionSnitch&lt;/a&gt;，GCE(GoogleComputerEngine) 用 
&lt;a href=&quot;http://www.datastax.com/documentation/cassandra/2.1/cassandra/architecture/architectureSnitchGoogle.html&quot; target=&quot;_blank&quot;&gt;GoogleCloudSnitch&lt;/a&gt;，混用 IaaS 跟一般傳統實體主機可以用 
&lt;a href=&quot;http://www.datastax.com/documentation/cassandra/2.1/cassandra/architecture/architectureSnitchGossipPF_c.html&quot; target=&quot;_blank&quot;&gt;GossipingPropertyFileSnitch&lt;/a&gt;。
&lt;br&gt;
&lt;br&gt;至於 ip 設定部份，其實只有一個重點&quot;機器內部內網溝通走 private ip，但是走到外網進行 broadcast 時要走 public ip&quot;。會這樣做的理由也很直覺，因為 public ip 是經由雲端服務綁定(e.g. AWS EIP)，VM 本身根本不知道自己有 public ip 這回事。
</description>
    </item>

    <item>
      <title>Cassandra 出現 HintsColumnFamily 異常巨大的解決辦法</title>
      <link>http://cloudtu.github.io/blog/2014/05/cassandra-hintscolumnfamily.html</link>
      <pubDate>Wed, 14 May 2014 15:47:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2014/05/cassandra-hintscolumnfamily.html</guid>
      <description>
這陣子在 Cassandra 的使用上遇到個很麻煩的怪事，那就是 ring 上某個 node 發生HintsColumnFamily 異常巨大的情況。執行下述指令後
&lt;br&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;ls -lh {cassandra_data_folder}/system/HintsColumnFamily*&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;我發現 HintsColumnFamily 吃掉了 10儿G 的 HD，出問題的 node 跑起來跟快掛掉沒兩樣，實在是災難一場。
&lt;br&gt;
&lt;br&gt;要如何解決這場災難，可以參考下列資料
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;coordinator node 負擔是否過重?資料寫入動作不要集中單一 coordinator node ，要分散到多個 node &lt;/li&gt;
 &lt;li&gt;coordinator node 在跟 ring 裡其它 node 進行通訊(cassandra gossiping)時，是否通訊不良?在 coordinator node 執行下述指令，看看發生 &#39;Timed out replaying hint&#39; 訊息的是哪儿個 node，想辦法改善這些 node 的網路品質&lt;br&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;cat {cassandra_root_folder}/system.log | grep &#39;Timed out replaying hint&#39; | less&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
 &lt;li&gt;因為 HintsColumnFamily 過於巨大，要等裡面的資料慢慢被消化完是無意義的。最有效率的解決辦法是直接刪除 HintsColumnFamily 檔案，把 hinted handoff 資料全部放生，然後再到各個發生 &#39;Timed out replaying hint&#39; 的 node 執行 repair 動作。處理步驟如下&lt;br&gt;
  &lt;ol&gt;
   &lt;li&gt;連線到 coordinator node &lt;/li&gt;
   &lt;li&gt;shutdown cassandra &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;nodetool -h coordinator_node disablegossip&lt;br&gt;nodetool -h coordinator_node disablethrift&lt;br&gt;nodetool -h coordinator_node drain&lt;br&gt;kill -9 {cassandra_service_pid}&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
   &lt;li&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;rm -rf {cassandra_data_folder}/system/HintsColumnFamily*&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
   &lt;li&gt;start cassandra&lt;/li&gt;
   &lt;li&gt;連線到發生 &#39;Timed out replaying hint&#39; 的那儿個node，各別都執行下述指令，修復資料不一致的儿個 columnfamily&lt;br&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;nodetool -h hint_fail_node repair {repaired_keyspace} {repaired_columnfamily} -pr&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
   &lt;li&gt;如果不想讓 HintsColumnFamily 的資料保留時間過久，可以修改 coordinator node 的 cassandra.yaml 設定檔，將 max_hint_window_in_ms 設定值改小。這個設定值預設是 3600000，代表裡面的資料預設只保留 1 小時，時間超過時就會被系統自動清除&lt;/li&gt;
  &lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>

    <item>
      <title>Cassandra Data Modeling 心得筆記</title>
      <link>http://cloudtu.github.io/blog/2014/02/cassandra-data-modeling.html</link>
      <pubDate>Sat, 15 Feb 2014 15:22:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2014/02/cassandra-data-modeling.html</guid>
      <description>
使用 Cassandra 時要設計出合適的 Data Model 是件苦差事，這篇是基於 Cassandra 2.0 版本整理出的一些心得，有興趣的人可以參考一下。以下...正文開始! 
&lt;br&gt;
&lt;br&gt;目前找到比較好而且完整的文章是「Cassandra Data Modeling Best Practices」這份文章(
&lt;a href=&quot;http://www.infoq.com/cn/articles/best-practice-of-cassandra-data-model-design&quot; target=&quot;_blank&quot;&gt;簡中版 part1&lt;/a&gt;,
&lt;a href=&quot;http://www.infoq.com/cn/articles/best-practices-cassandra-data-model-design-part2&quot; target=&quot;_blank&quot;&gt;簡中版 part2&lt;/a&gt;)(
&lt;a href=&quot;http://www.ebaytechblog.com/2012/07/16/cassandra-data-modeling-best-practices-part-1&quot; target=&quot;_blank&quot;&gt;原文版 part1&lt;/a&gt;,
&lt;a href=&quot;http://www.ebaytechblog.com/2012/08/14/cassandra-data-modeling-best-practices-part-2&quot; target=&quot;_blank&quot;&gt;原文版 part2&lt;/a&gt;)，建議先把它整個讀過一遍。讀完後接著可以看看原作著以這份文章為基礎整理出來的下面這份投影片
&lt;br&gt;
&lt;iframe allowfullscreen frameborder=&quot;0&quot; height=&quot;356&quot; marginheight=&quot;0&quot; marginwidth=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;http://www.slideshare.net/slideshow/embed_code/21134577&quot; style=&quot;border-width: 1px 1px 0; border: 1px solid #CCC; margin-bottom: 5px; max-width: 100%;&quot; width=&quot;427&quot;&gt; &lt;/iframe&gt; 
&lt;br&gt;
&lt;div style=&quot;margin-bottom: 5px;&quot;&gt;
 &lt;b&gt; &lt;a href=&quot;https://www.slideshare.net/jaykumarpatel/cassandra-data-modeling-best-practices&quot; target=&quot;_blank&quot; title=&quot;Cassandra Data Modeling Best Practices&quot;&gt;Cassandra Data Modeling Best Practices&lt;/a&gt; &lt;/b&gt; from 
 &lt;b&gt;&lt;a href=&quot;http://www.slideshare.net/jaykumarpatel&quot; target=&quot;_blank&quot;&gt;Jay Patel&lt;/a&gt;&lt;/b&gt; 
&lt;/div&gt;
&lt;br&gt;不過，既然都用了 Cassandra 2.0，我想多數人應該會盡量用 CQL3 來操作資料，讓自己不要用的那麼痛苦。利用 CQL3 進行 Modeling 可以參考下面這份投影片
&lt;br&gt;
&lt;iframe allowfullscreen frameborder=&quot;0&quot; height=&quot;356&quot; marginheight=&quot;0&quot; marginwidth=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;http://www.slideshare.net/slideshow/embed_code/17917955&quot; style=&quot;border-width: 1px 1px 0; border: 1px solid #CCC; margin-bottom: 5px; max-width: 100%;&quot; width=&quot;427&quot;&gt; &lt;/iframe&gt; 
&lt;br&gt;
&lt;div style=&quot;margin-bottom: 5px;&quot;&gt;
 &lt;b&gt; &lt;a href=&quot;https://www.slideshare.net/jericevans/cassandra-by-example-data-modelling-with-cql3&quot; target=&quot;_blank&quot; title=&quot;Cassandra By Example: Data Modelling with CQL3&quot;&gt;Cassandra By Example: Data Modelling with CQL3&lt;/a&gt; &lt;/b&gt; from 
 &lt;b&gt;&lt;a href=&quot;http://www.slideshare.net/jericevans&quot; target=&quot;_blank&quot;&gt;Eric Evans&lt;/a&gt;&lt;/b&gt; 
&lt;/div&gt;
&lt;br&gt;依據上面儿份資料，整理出的 Modeling 重點如下
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;中心思想 
  &lt;ul&gt;
   &lt;li&gt;依據「系統如何查詢資料」來設計 Data Model&lt;/li&gt;
   &lt;li&gt;不要以傳統 RDBMS 的 relational table 思維來設計 Data Model，要把 column family 想成是 HashMap&amp;lt;RowKey,&amp;nbsp; SortedMap&amp;lt;ColumnName, ColumnValue&amp;gt;&amp;gt;&lt;/li&gt;
   &lt;li&gt;CQL 只是讓資料操作起來「長的像」RDBMS 的 relational table，Modeling 時請先忘掉 CQL&lt;/li&gt;
   &lt;li&gt;設計之初就要考量是不是會用到 Secondary Index &lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;效能考量 
  &lt;ul&gt;
   &lt;li&gt;使用 wide row，wide row 在 ordering, grouping, filtering 有效能優勢&lt;/li&gt;
   &lt;li&gt;使用合適的 row key (挑合適的 row key 其實就是在做 sharding) 以避免資料過度集中在 ring 上特定 node，因而避免發生 hotspot 危機&lt;/li&gt;
   &lt;li&gt;為了增加讀(select)寫(upsert)速度，Data Model 進行 De-normalize，部份 column family 許可發生 column duplicate。簡單來說就是用空間換取時間&lt;/li&gt;
   &lt;li&gt;read-heavy data 跟 write-heavy data 放在不同 column family。如此一來 read-heavy data 可以常常進到 row cache，讀(select)資料時會快很多&lt;/li&gt;
   &lt;li&gt;熱門資料與冷門資料放在不同 column family&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;其它 
  &lt;ul&gt;
   &lt;li&gt;CQL3 的 compound primary key 摘要 
    &lt;ul&gt;
     &lt;li&gt;語法範列 
      &lt;ul&gt;
       &lt;li&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;PRIMARY KEY(partition_key,clustering_column_1,clustering_column_2)&lt;/code&gt;&lt;/pre&gt;partition_key 對應到 column family 的 row key，clustering_column_1、clustering_column_2 則是 composite column&lt;/li&gt;
       &lt;li&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;PRIMARY KEY((partition_key1,partition_key2),clustering_column_1,clustering_column_2,clustering_column_3)&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;partition_key1 + partition_key2 組合了 column family 的 row key，clustering_column_1、clustering_column_2、clustering_column_3 則是 composite column &lt;/li&gt;
      &lt;/ul&gt;&lt;/li&gt;
     &lt;li&gt;圖解
      &lt;ol&gt;
       &lt;li&gt;先用 CQL3 執行下述指令產生 table 與資料 &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;CREATE TABLE passbook (&lt;br&gt; user varchar,&lt;br&gt; date timestamp,&lt;br&gt; deposit int,&lt;br&gt; withdraw int, &lt;br&gt; PRIMARY KEY(user,date)&lt;br&gt;);&lt;br&gt;INSERT INTO passbook (user, date, deposit,withdraw) VALUES (&#39;nekobean&#39;,&#39;2014-01-01&#39;,1000,10);&lt;br&gt;INSERT INTO passbook (user, date, withdraw) VALUES (&#39;nekobean&#39;,&#39;2014-01-02&#39;,20);&lt;br&gt;INSERT INTO passbook (user, date, withdraw) VALUES (&#39;nekobean&#39;,&#39;2014-01-03&#39;,30);&lt;br&gt;INSERT INTO passbook (user, date, withdraw) VALUES (&#39;duke&#39;,&#39;2014-02-01&#39;,300);&lt;br&gt;INSERT INTO passbook (user, date, withdraw) VALUES (&#39;duke&#39;,&#39;2014-02-02&#39;,200);&lt;br&gt;INSERT INTO passbook (user, date, deposit, withdraw) VALUES (&#39;duke&#39;,&#39;2014-02-03&#39;,2000, 100);&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
       &lt;li&gt;產生的資料利用 CQL3 與 CLI 查詢的對照如下圖&lt;br&gt;&lt;a href=&quot;../../../img/2014/02/201402151522_1.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;../../../img/2014/02/201402151522_1.png&quot; height=&quot;115&quot; width=&quot;400&quot;&gt;&lt;/a&gt;&lt;/li&gt;
       &lt;li&gt;也可以參考 datastax 寫的&lt;a href=&quot;http://www.datastax.com/docs/1.1/ddl/column_family#composite-columns&quot; target=&quot;_blank&quot;&gt;這份文件&lt;/a&gt;裡針對 composite columns 章節設計出來的 timeline table 圖例解說&lt;/li&gt;
      &lt;/ol&gt;&lt;/li&gt;
    &lt;/ul&gt;&lt;/li&gt;
   &lt;li&gt;CQL3 的 insert、update 語法在異動資料時都是做 upsert 動作。也就是說二者在異動資料的邏輯相同，資料不存在的話進行新增(insert)動作，資料若存在則進行更新(update)動作&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
</description>
    </item>

    <item>
      <title>把 router 當 switch 用的設定步驟</title>
      <link>http://cloudtu.github.io/blog/2014/02/router-switch.html</link>
      <pubDate>Fri, 7 Feb 2014 11:26:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2014/02/router-switch.html</guid>
      <description>
在 office 偶爾會遇到要連到同網段機器來做一些事，可是平常我都把自己的終端設備掛在自己帶來的 router 之下，這時臨時要去生個 switch 來用實在有點麻煩。後來 google 了一下，發現只要照下面二個步驟就可以讓 router 變身成 switch，還蠻簡單的，有這需求的人可以參考一下 ... :) 
&lt;br&gt;
&lt;ol&gt;
 &lt;li&gt;連進 router 的 web console，把 dhcp server 功能關掉&lt;/li&gt;
 &lt;li&gt;把原先接在 wan port 的網路線改接到 lan port&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>

    <item>
      <title>cassandra java client library 心得筆記</title>
      <link>http://cloudtu.github.io/blog/2013/12/cassandra-java-client-library.html</link>
      <pubDate>Wed, 25 Dec 2013 09:56:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2013/12/cassandra-java-client-library.html</guid>
      <description>
沒空深入研究，先寫個簡單筆記
&lt;br&gt;
&lt;ul&gt;
 &lt;li&gt;我心目中的侯選者&lt;br&gt;
  &lt;ol&gt;
   &lt;li&gt;&lt;a href=&quot;https://github.com/hector-client/hector&quot; target=&quot;_blank&quot;&gt;hector&lt;/a&gt;&lt;br&gt;
    &lt;ul&gt;
     &lt;li&gt;最早出現&lt;/li&gt;
     &lt;li&gt;支援 thrift api 跟 cql&lt;/li&gt;
    &lt;/ul&gt;&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;https://github.com/Netflix/astyanax&quot; target=&quot;_blank&quot;&gt;astyanax&lt;/a&gt;&lt;br&gt;
    &lt;ul&gt;
     &lt;li&gt;在 hector 之後出現，有 netflix 這支超大的白老鼠背書&lt;/li&gt;
     &lt;li&gt;支援 thrift api 跟 cql&lt;/li&gt;
    &lt;/ul&gt;&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;https://github.com/datastax/java-driver&quot; target=&quot;_blank&quot;&gt;DataStax Java Driver for Apache Cassandra&lt;/a&gt;&lt;br&gt;
    &lt;ul&gt;
     &lt;li&gt;datastax 這個半官方發布的 client lib&lt;/li&gt;
     &lt;li&gt;只支援 cql&lt;/li&gt;
     &lt;li&gt;server 端 cassandra 版本必需 &amp;gt;= 1.2&lt;/li&gt;
     &lt;li&gt;語法跟 jdbc 很像&lt;/li&gt;
    &lt;/ul&gt;&lt;/li&gt;
  &lt;/ol&gt;&lt;/li&gt;
 &lt;li&gt;使用的白老鼠(由多至少)&lt;br&gt;hector &amp;gt; astyanax &amp;gt; datastax java driver&lt;/li&gt;
 &lt;li&gt;api 操作的便捷性(由最好用到最難用)&lt;br&gt;datastax java driver &amp;gt; astyanax &amp;gt; hector&lt;/li&gt;
 &lt;li&gt;補充說明&lt;br&gt;datastax java driver 的文件跟程式碼都還很新，白老鼠不夠多。有沒有隱性地雷也不是很確定，要多去網路上爬一下有沒有人用了後變苦主。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

  </channel>
</rss>
