<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
      <meta charset="utf-8" />
      <title>老涂的咁仔店</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <meta name="description" content="" />
      <meta name="author" content="cloudtu" />
      <meta name="keywords" content="" />

      <!-- Le styles -->
      <link rel="stylesheet" href="/css/bootstrap.min.css" />
      <link rel="stylesheet" href="/css/base.css" />
      <link rel="stylesheet" href="/css/prettify.css" />
  </head>
  <body onload="prettyPrint()">

  <div id="wrap">
    <div>

    <!-- Fixed navbar -->
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" shape="rect" href="/index.html">CloudTu's blog</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" shape="rect">Tags<b class="caret"></b></a>
              <ul class="dropdown-menu scrollable-menu">
                <li>
                  <a shape="rect" href="/tags/android.html">android</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/aws.html">aws</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/bitbucket.html">bitbucket</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/cassandra.html">cassandra</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/connection-pool.html">connection-pool</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/eclipse.html">eclipse</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/gae.html">gae</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/git.html">git</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/github.html">github</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/gradle.html">gradle</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/groovy.html">groovy</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/guava.html">guava</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/java.html">java</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/javascript.html">javascript</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/jax-rs.html">jax-rs</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/jbake.html">jbake</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/jersey.html">jersey</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/jetty.html">jetty</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/jquery.html">jquery</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/lambda.html">lambda</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/linux.html">linux</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/mac.html">mac</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/nexus7.html">nexus7</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/notepad-plus-plus.html">notepad-plus-plus</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/oauth2.html">oauth2</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/olap.html">olap</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/python.html">python</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/remote-control.html">remote-control</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/router.html">router</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/selenium.html">selenium</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/spring.html">spring</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/ssh.html">ssh</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/switch.html">switch</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/tomato.html">tomato</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/tomcat.html">tomcat</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/windows7.html">windows7</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/喔~鋼普拉.html">喔~鋼普拉</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/心情記事.html">心情記事</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/敗~敗家啦.html">敗~敗家啦</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/版控系統.html">版控系統</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/程式語言.html">程式語言</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/阿殺不魯.html">阿殺不魯</a>
                </li>
                <li>
                  <a shape="rect" href="/tags/電影、戲劇.html">電影、戲劇</a>
                </li>
              </ul>
            </li>
            <li><a shape="rect" href="/archive.html">Archive</a></li>
            <li><a shape="rect" href="/feed.xml">RSS</a></li>
            <li><a shape="rect" href="/about.html">About</a></li>
          </ul>

          <ul class="nav navbar-nav navbar-right">
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" shape="rect">Search<b class="caret"></b></a>
              <ul class="dropdown-menu google_search">
                <li>
                  <script xml:space="preserve">
                  //<![CDATA[
                    (function() {
                      var cx = '001738447238955852876:bkori8ynpby';
                      var gcse = document.createElement('script');
                      gcse.type = 'text/javascript';
                      gcse.async = true;
                      gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
                          '//cse.google.com/cse.js?cx=' + cx;
                      var s = document.getElementsByTagName('script')[0];
                      s.parentNode.insertBefore(gcse, s);
                    })();
                  //]]>
                  </script>
                  <gcse:searchbox-only></gcse:searchbox-only>
                </li>
              </ul>
            </li>
          </ul>

        </div><!--/.nav-collapse -->
      </div>
    </div>

  </div>
    <div class="container">
      <div class="index_page_banner">
        <h1 style="margin-top: 0px; margin-bottom: 0px;">老涂的咁仔店</h1>
        <p style="margin-top: 50px; margin-bottom: 0px;">記載生活點滴、敗家記事、程式撰寫...etc</p>
      </div>

      <div>
        <a href="blog/2021/03/spring-security-jwt-auth-teach.html" shape="rect"><h1>spring boot + spring security + jwt(json web token) 實作登入認証(authentication)與授權(authorization)</h1></a>
        <p>2021-03-12</p>

        <p>
          <em>Tags:
            <span>
              <a shape="rect" href="tags/程式語言.html">程式語言</a>
              <span>,</span>
            </span>
            <span>
              <a shape="rect" href="tags/java.html">java</a>
              <span>,</span>
            </span>
            <span>
              <a shape="rect" href="tags/spring.html">spring</a>
              
            </span>
          </em>
        </p>

        <p><h2>在開始之前</h2><p>建議先搞懂 spring security 裡的認証(authentication)與援權(authorization)功能的程式碼如何運作，不懂的可以看一下我之前寫的 <a href="/blog/2021/03/spring-security-auth-memo.html">spring security 裡的認証&amp;援權原理說明</a> ，把細節搞懂。不然看完實作範例後很可能不知道程式為何這樣寫就可以弄出 token base auth 功能，知其然不知其所以然。</p><h2>實作教學</h2><p>別人的教學文已經超詳細，直接看下列這些別人的文章吧 :)</p>
<ul>
  <li><p>重拾後端之Spring Boot（四）：使用JWT和Spring Security保護REST API</p>
  <ul>
    <li>文章在<a href="https://www.jianshu.com/p/6307c89fe3fa">這裡</a></li>
    <li>sample code 在 <a href="https://github.com/wpcfan/spring-boot-tut/tree/chap04">git project</a> 裡的 <code>chap04</code> branch</li>
  </ul></li>
  <li><p>Spring Boot Token based Authentication with Spring Security &amp; JWT</p>
  <ul>
    <li>文章在<a href="https://bezkoder.com/spring-boot-jwt-authentication/">這裡</a></li>
    <li>sample code 在<a href="https://github.com/bezkoder/spring-boot-spring-security-jwt-authentication">這裡</a></li>
  </ul></li>
  <li><p><a href="https://bezkoder.com/spring-boot-jwt-mysql-spring-security-architecture/">Spring Boot 2 JWT Authentication with Spring Security</a></p></li>
  <li><p>Vincent Zheng blog 裡跟 Spring Security 相關系列文章</p>
  <ul>
    <li><a href="https://medium.com/chikuwa-tech-study/spring-boot-%E7%AC%AC17%E8%AA%B2-spring-security%E7%9A%84%E9%A9%97%E8%AD%89%E8%88%87%E6%8E%88%E6%AC%8A-263afe44ac20">Spring Boot-第17課-Spring Security的驗證與授權</a></li>
    <li><a href="https://medium.com/chikuwa-tech-study/spring-boot-%E7%AC%AC18%E8%AA%B2-%E5%B8%B3%E5%AF%86%E9%A9%97%E8%AD%89%E8%88%87%E7%94%A2%E7%94%9Ftoken-79d9ccc2b6fd">Spring Boot-第18課-帳密驗證與產生Token</a></li>
    <li><a href="https://medium.com/chikuwa-tech-study/spring-boot-%E7%AC%AC19%E8%AA%B2-%E5%BE%9Etoken%E9%A9%97%E8%AD%89%E4%BD%BF%E7%94%A8%E8%80%85%E8%BA%AB%E4%BB%BD-8818cca1361d">Spring Boot-第19課-從Token驗證使用者身份</a></li>
  </ul></li>
</ul><h2>我改寫出來的教學範例程式</h2><p>不過，別人寫的教學範例程式提到的細節太多了，常會用到 NoSQL DB 或是 RMDB 來存放用戶個人資料，導致範例程式複雜化。所以我改寫出了一個簡化版的教學範例，放在<a href="https://github.com/cloudtu/spring-security-jwt-auth-teach">我的 github</a>。程式裡關鍵處都有加上註解說明，有興趣的人可以看看。</p></p>

        <hr />
      </div>

      <div>
        <a href="blog/2021/03/spring-security-auth-memo.html" shape="rect"><h1>spring security 裡的認証(authentication) &amp; 援權(authorization) 原理說明</h1></a>
        <p>2021-03-12</p>

        <p>
          <em>Tags:
            <span>
              <a shape="rect" href="tags/程式語言.html">程式語言</a>
              <span>,</span>
            </span>
            <span>
              <a shape="rect" href="tags/java.html">java</a>
              <span>,</span>
            </span>
            <span>
              <a shape="rect" href="tags/spring.html">spring</a>
              
            </span>
          </em>
        </p>

        <p><h2>前言</h2><p>要實作 spring security 裡面認証(authentication) &amp; 援權(authorization) 功能時，大多數文件只會說要實作 UserDetailsService、UserDetails、WebSecurityConfigurerAdapter 這儿個 class 或 inteface 就可以搞定一切。但這儿個 class 間到底怎麼交互作用通常都不提，讓人覺得實作參考的範例程式碼很簡單易懂、但背後原理卻不知怎麼回事。程式這樣改一改就可以跑讓人覺得很像黑魔法，哪天要微調時很可能因為不知背後原理就改不動了。</p><p>因此我決定把背後原理搞清楚並整理出重點摘要。既然是摘要只會挑關鍵重點，建議搭配 spring security 裡的 source code 一起看，比較好理解內容。</p><h2>認証與援權功能的程式碼如何運作</h2><p>程式碼依照下列順序進行認証動作</p>
<ol>
  <li>用戶使用帳號和密碼進行登錄。</li>
  <li>在 Filter 裡將獲取到的用戶名和密碼封裝成一個實現了 Authentication interface 的 UsernamePasswordAuthenticationToken。</li>
  <li>將上述產生的 token 傳遞給 AuthenticationManager 進行登錄認證。</li>
  <li>AuthenticationManager 認證成功後將會返回一個 <code>封裝了用戶權限等資料</code> 的 Authentication 實例。而且這個實例內容裡 <code>不帶用戶憑証或密碼</code>。</li>
  <li>通過呼叫 SecurityContextHolder.getContext().setAuthentication(...) method 將 AuthenticationManager 在認證成功後產生的 Authentication 實例賦予給當前的 SecurityContext。</li>
</ol><p>上述流程項次 1,2,3,5 實作程式碼可參考 <code>BasicAuthenticationFilter.doFilterInternal(...)</code> method，source code 與關鍵說明如下</p>
<!--?prettify linenums=true?-->
<pre><code class="java">    @Override
    protected void doFilterInternal(HttpServletRequest request,HttpServletResponse response, FilterChain chain)
                    throws IOException, ServletException {
        ...略

        try {
            String[] tokens = extractAndDecodeHeader(header, request);

            String username = tokens[0];

            if (authenticationIsRequired(username)) {
                // step1. 將用戶輸入的帳號密碼轉換成 UsernamePasswordAuthenticationToken DTO
                UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, tokens[1]);
                authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));
                
                // step2. 利用 AuthenticationManager.authenticate(...) method 進行用戶認証
                //        認証失敗時丟出 Exception，認証成功時將用戶資料(指 UserDetails)、權限存
                //        成一個新的 Authentication DTO
                //
                //        AuthenticationManager.authenticate(...) method 裡的 &quot;尋找用戶資料&quot; 程式片段
                //        通常是呼叫 UserDetailsService.loadUserByUsername(...) method
                Authentication authResult = this.authenticationManager.authenticate(authRequest);

                // step3. SecurityContextHolder 存放授權成功的 Authentication DTO
                SecurityContextHolder.getContext().setAuthentication(authResult);
            }

        }
        catch (AuthenticationException failed) {
            // 授權失敗時，要把 SecurityContextHolder 裡的 Authentication DTO 清除
            SecurityContextHolder.clearContext();
        }

        ...略
    }
</code></pre><p>上述流程項次 4 實作程式碼可參考 <code>AbstractUserDetailsAuthenticationProvider.authenticate(...)</code> method，source code 與關鍵說明如下</p>
<!--?prettify linenums=true?-->
<pre><code class="java">    public Authentication authenticate(Authentication authentication)throws AuthenticationException {
        ...略

        // Determine username
        String username = (authentication.getPrincipal() == null) ? &quot;NONE_PROVIDED&quot;: authentication.getName();

        boolean cacheWasUsed = true;
        UserDetails user = this.userCache.getUserFromCache(username);

        if (user == null) {
            cacheWasUsed = false;

            try {
                // step1. retrieveUser(...) method 呼叫 UserDetailsService.loadUserByUsername(...) method 
                //        查出用戶資料(指 UserDetails)
                user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication);
            }
            catch (UsernameNotFoundException notFound) {
                ...略

                throw notFound;
            }

        }

        try {
            ...略

            // step2. 用戶資料(指 UserDetails) 跟 UsernamePasswordAuthenticationToken 內容比對
            //        進行用戶認証，認証失敗時丟出 Exception。
            additionalAuthenticationChecks(user,(UsernamePasswordAuthenticationToken) authentication);
        }
        catch (AuthenticationException exception) {
            ...略

            throw exception;
        }

        ...略

        // step3. 認証成功時將用戶資料(指 UserDetails)、權限存成一個新的 Authentication DTO
        return createSuccessAuthentication(principalToReturn, authentication, user);
    }
</code></pre><h2>認証與援權功能對應的關鍵 class 與 interface</h2>
<ul>
  <li><p>Authentication</p><p>Authentication interface 用來存放用戶認證資料，在用戶登錄認證之前相關資料會封裝為一個 Authentication instance，在登錄認證成功之後又會生成一個資料更全面，包含用戶權限等資料的 Authentication instance，然後把它保存在 SecurityContextHolder 所持有的 SecurityContext 中，供後續的程序進行呼叫，如訪問權限的鑑定等。</p>
  <pre><code>Authentication.getPrincipal() : 認証成功前存放 &quot;用戶登入id&quot;，認証成功後存放 &quot;用戶對應的 UserDetails&quot;
Authentication.getCredentials() : 認証成功前存放 &quot;用戶登入密碼&quot;，認証成功後通常不帶任何資料
Authentication.getAuthorities() : 認証成功前不帶任何資料，認証成功後存放 &quot;用戶權限&quot;
</code></pre></li>
  <li><p>AuthenticationManager 和 AuthenticationProvider</p><p>AuthenticationManager 是一個用來處理認證（Authentication）請求的 interface，裡面只定義了 authenticate() 方法，該方法只接收一個代表認證請求的 Authentication 實例作為參數，如果認證成功，則會返回一個封裝了當前用戶權限等資料的 Authentication 實例進行返回。</p><p>AuthenticationManager 的預設實現是 ProviderManager。認證是由 AuthenticationManager 來管理的，但是真正進行認證的是 AuthenticationManager 中定義的 AuthenticationProvider。AuthenticationManager 中可以定義有多個 AuthenticationProvider。如果沒有指定對應關聯的 AuthenticationProvider 實例，Spring Security 預設會使用 DaoAuthenticationProvider。DaoAuthenticationProvider 在進行認證的時候需要一個 UserDetailsService 來獲取用戶的資料 UserDetails。</p><p>檢核認證請求最常用的方法是根據請求的用戶名產生對應的 UserDetails，然後比對 UserDetails 的密碼與認證請求的密碼是否一致，一致則表示認證通過。Spring Security 內部的 DaoAuthenticationProvider 就是使用的這種方式。其內部使用 UserDetailsService 來負責產生 UserDetails。在認證成功以後會產生包含用戶權限等資料的的 UserDetails 實例，並將它封裝在返回的認證成功 Authentication 實例。認證成功返回的 Authentication 實例將會保存在當前的 SecurityContext 中。預設情況下，在認證成功後 ProviderManager 將清除返回的 Authentication 中的憑證資料，如密碼。</p></li>
  <li><p>UserDetailsService</p><p>通過 Authentication.getPrincipal() 的返回類型是 Object，但很多情況下其返回的其實是一個 UserDetails 實例。UserDetails interface 定義了一些可以獲取用戶名、密碼、權限等與認證相關的資料的方法。登錄認證的時候 Spring Security 會通過 UserDetailsService 的 loadUserByUsername() 方法獲取對應的 UserDetails 進行認證，認證通過後會將該 UserDetails 放到認證通過的 Authentication 的 principal，然後再把該 Authentication 存入到 SecurityContext 中。之後如果需要使用用戶資料的時候就是通過 SecurityContextHolder 獲取存放在 SecurityContext 中的 Authentication 的 principal。</p></li>
  <li><p>GrantedAuthority</p><p>Authentication 的 getAuthorities() 可以返回當前 Authentication 實例擁有的權限，即當前用戶擁有的權限。其返回型別是 Collection&lt;? extends GrantedAuthority&gt;，每一個 GrantedAuthority 實例代表賦予給當前用戶的一種權限。</p></li>
  <li><p>SecurityContextHolder</p><p>SecurityContextHolder 是用來保存 SecurityContext，SecurityContext 中含有當前正在訪問系統的用戶的詳細資料。預設情況下，SecurityContextHolder 將使用 ThreadLocal 來保存 SecurityContext，這也就意味著在處於同一線程中的方法中我們可以從 ThreadLocal 中獲取到當前的 SecurityContext。</p><p>通過 <code>SecurityContextHolder.getContext().getAuthentication().getPrincipal()</code> 可以獲取到代表當前已通過認証與授權的用戶資料，這個實例通常是 UserDetails 實例。</p></li>
</ul><h2>所有 Filter 簡述</h2><p>Spring Security 底層是通過一系列的 Filter 來管理，每個 Filter 都有其自身的功能，而且各個 Filter 在功能上還有關聯關係，所以它們的順序也是非常重要的。Spring Security 對 FilterChain 中 Filter 順序有嚴格的規定的，Spring Security 對那些預設的 Filter 指定了它們的位置。</p><p>Spring Security 已經定義了一些 Filter，不管實際應用中你用到了哪些，它們應當保持如下順序。</p>
<ol>
  <li><p>ChannelProcessingFilter</p><p>如果你訪問的 channel 錯了，那首先就會在 channel 之間進行跳轉，如 http 變為 https。</p></li>
  <li><p>SecurityContextPersistenceFilter</p><p>開始進行 request 的時候就可以在 SecurityContextHolder 中建立一個 SecurityContext，然後在請求結束的時候，任何對 SecurityContext 的改變都可以被 copy 到 HttpSession。</p></li>
  <li><p>ConcurrentSessionFilter</p><p>它使用 SecurityContextHolder 的功能，而且更新對應 session 的最後更新時間，以及通過 SessionRegistry 獲取當前的 SessionInformation 以檢查當前的 session 是否已經過期，過期則會呼叫 LogoutHandler。</p></li>
  <li><p>認證處理機制</p><p>如 UsernamePasswordAuthenticationFilter，CasAuthenticationFilter，BasicAuthenticationFilter 等，以至於 SecurityContextHolder 可以被更新為包含一個有效的 Authentication 請求。</p></li>
  <li><p>SecurityContextHolderAwareRequestFilter</p><p>它將會把 HttpServletRequest 封裝成一個繼承自 HttpServletRequestWrapper 的 SecurityContextHolderAwareRequestWrapper，同時使用 SecurityContext 實現了 HttpServletRequest 中與安全相關的方法。</p></li>
  <li><p>JaasApiIntegrationFilter</p><p>如果 SecurityContextHolder 中擁有的 Authentication 是一個 JaasAuthenticationToken，那麼該 Filter 將使用包含在 JaasAuthenticationToken 中的 Subject 繼續執行 FilterChain。</p></li>
  <li><p>RememberMeAuthenticationFilter</p><p>如果之前的認證處理機制沒有更新 SecurityContextHolder，並且用戶請求包含了一個 Remember-Me 對應的 cookie，那麼一個對應的 Authentication 將會設給 SecurityContextHolder。</p></li>
  <li><p>AnonymousAuthenticationFilter</p><p>如果之前的認證機制都沒有更新 SecurityContextHolder 擁有的 Authentication，那麼一個 AnonymousAuthenticationToken 將會設給 SecurityContextHolder。</p></li>
  <li><p>ExceptionTransactionFilter</p><p>用於處理在 FilterChain 範圍內拋出的 AccessDeniedException 和 AuthenticationException，並把它們轉換為對應的 Http 錯誤碼返回或者對應的頁面。</p></li>
  <li><p>FilterSecurityInterceptor，保護 Web URI，並且在訪問被拒絕時拋出異常。</p></li>
</ol><h2>reference document</h2>
<ul>
  <li><p><a href="http://wiki.jikexueyuan.com/project/spring-security/">初識 Spring Security</a></p><p>認証與援權功能在下述這儿個章節</p>
  <ul>
    <li>核心類簡介</li>
    <li>認證簡介</li>
    <li>AuthenticationProvider</li>
    <li>Filter</li>
  </ul></li>
  <li><p><a href="https://juejin.im/post/5a4f213af265da3e3c6bf47d">Spring Security源碼分析二：Spring Security授權過程</a></p></li>
  <li><p><a href="https://www.baeldung.com/get-user-in-spring-security">retrieve the user details in Spring Security</a></p></li>
  <li><p><a href="https://juejin.im/post/5a1980825188252abc5e0fd1">聊聊 spring security 的 permitAll 以及 ignore</a></p>
  <ul>
    <li>permitAll() 情況下，每個 reqeust 還是會走過所有 filter</li>
    <li>ignoring() 清況下，每個 reqeust 不會走過任何 filter，相當於不走 spring security</li>
  </ul></li>
</ul></p>

        <hr />
      </div>

      <div>
        <a href="blog/2018/08/guava-cache-memo.html" shape="rect"><h1>Guava Cache 使用說明</h1></a>
        <p>2018-08-29</p>

        <p>
          <em>Tags:
            <span>
              <a shape="rect" href="tags/程式語言.html">程式語言</a>
              <span>,</span>
            </span>
            <span>
              <a shape="rect" href="tags/java.html">java</a>
              <span>,</span>
            </span>
            <span>
              <a shape="rect" href="tags/guava.html">guava</a>
              
            </span>
          </em>
        </p>

        <p><h2>基本用法</h2><p>請參考下列文章</p>
<ul>
  <li><a href="https://segmentfault.com/a/1190000011105644">Guava Cache 用法介紹</a></li>
</ul><h2>CacheBuilder class 裡的 expireAfterWrite, expireAfterAccess, refreshAfterWrite method 區別</h2>
<ul>
  <li><p>expireAfterAccess</p>
  <ul>
    <li>一定時間內沒有讀寫，會移除該cache key，下次取的時候從 raw data (e.g. database) 裡取</li>
    <li>在更新 cache key 對應內容時，會 <code>block</code> 所有存取該 cache key 的 thread</li>
    <li>expireAfterAccess 行為分析請參考下列文章
    <ul>
      <li><a href="https://blog.csdn.net/aitangyong/article/details/53491867">Guava Cache特性：對於同一個key，只讓一個請求回源load數據，其他線程阻塞等待結果</a></li>
    </ul></li>
  </ul></li>
  <li><p>expireAfterWrite</p>
  <ul>
    <li>一定時間內沒有創建或覆寫時，會移除該 cache key，下次取的時候從 raw data (e.g. database) 裡取</li>
    <li>在更新 cache key 對應內容時，會 <code>block</code> 所有存取該 cache key 的所有 thread</li>
    <li>expireAfterWrite 是時間到了就 expire。expireAfterAccess 則是以 <code>上次取存的時間點</code> 為基準來記算何時會 expire，也就是說只要一直被存取就不會 expire</li>
  </ul></li>
  <li><p>refreshAfterWrite</p>
  <ul>
    <li>指定時間內沒有被創建或覆寫，在指定時間過後再次訪問時，會去更新 cache key 對應之值，在新值沒有到來之前，始終返回舊值。<code>注意!是再次訪問，也就是未訪問前可能都不會更新。</code></li>
    <li>在更新 cache key 對應內容時，<code>不會 block</code> 所有存取該 cache key 的 thread</li>
    <li>CacheBuilder 要產生 LoadingCache 時才可以叫用這個 method，不然會產生 <code>refreshAfterWrite requires a LoadingCache</code> exception</li>
    <li>跟 expireAfterAccess(或 expireAfterWrite) 區別
    <ul>
      <li>指定時間過後，expireAfterAccess(或 expireAfterWrite) 是 remove cache key，下次訪問是 <code>同步(sync)</code> 去獲取返回新值。新值未取回前，所有要取新值 的 thread 都會被 block。</li>
      <li>refresh 是指定時間後，不會 remove cache key，<code>直到下次訪問</code> 才以 <code>非同步(async)</code> 方式 refresh cache。在 refresh cache 動作完成前，大多數針對該 cache key 的請求 thread 會立刻返回舊值，不會被 block</li>
    </ul></li>
    <li>refreshAfterWrite 行為分析請參考下列文章
    <ul>
      <li><a href="https://blog.csdn.net/aitangyong/article/details/53504253">Guava Cache特性：refreshAfterWrite只阻塞回源線程，其他線程返回舊值</a></li>
    </ul></li>
  </ul></li>
</ul><h2>CacheBuilder class 裡的 expireAfterWrite, refreshAfterWrite method 可以一起使用</h2><p>二者一起使用時的行為請參考下列文章</p>
<ul>
  <li><p><a href="https://blog.csdn.net/abc86319253/article/details/53020432">深入Guava Cache的refresh和expire刷新機制</a></p><p>重點是這一段</p>
  <blockquote><p>可以看出refreshAfterWrite和expireAfterWrite兩種方式各有優缺點，各有使用場景。那麼能否在refreshAfterWrite和expireAfterWrite找到一個折中？比如說控制緩存每1s進行refresh，如果超過2s沒有訪問，那麼則讓緩存失效，下次訪問時不會得到舊值，而是必須得待新值加載。由於guava官方文檔沒有給出一個詳細的解釋，查閱一些網上資料也沒有得到答案，因此只能對源碼進行分析，尋找答案。經過分析，當同時使用兩者的時候，可以達到預想的效果，這真是一個好消息吶！</p>
  </blockquote></li>
  <li><p><a href="https://github.com/google/guava/wiki/CachesExplained#refresh">官方文件說明</a></p><p>重點是這一段，不過我沒有很懂它表達的意思</p>
  <blockquote><p>In contrast to expireAfterWrite, refreshAfterWrite will make a key eligible for refresh after the specified duration, but a refresh will only be actually initiated when the entry is queried. (If CacheLoader.reload is implemented to be asynchronous, then the query will not be slowed down by the refresh.) So, for example, you can specify both refreshAfterWrite and expireAfterWrite on the same cache, so that the expiration timer on an entry isn't blindly reset whenever an entry becomes eligible for a refresh, so if an entry isn't queried after it comes eligible for refreshing, it is allowed to expire.</p>
  </blockquote></li>
</ul><h2>reference document</h2>
<ul>
  <li><a href="https://segmentfault.com/a/1190000011105644">Guava Cache 用法介紹</a></li>
  <li><a href="https://blog.csdn.net/aitangyong/article/details/53491867">Guava Cache特性：對於同一個key，只讓一個請求回源load數據，其他線程阻塞等待結果</a></li>
  <li><a href="https://blog.csdn.net/aitangyong/article/details/53504253">Guava Cache特性：refreshAfterWrite只阻塞回源線程，其他線程返回舊值</a></li>
  <li><a href="https://my.oschina.net/scipio/blog/551475">guava緩存的expireAfterWrite與refreshAfterWrite的區別</a></li>
  <li><a href="https://blog.csdn.net/abc86319253/article/details/53020432">深入Guava Cache的refresh和expire刷新機制</a></li>
</ul></p>

        <hr />
      </div>

      <div>
        <a href="blog/2017/12/spring-restful-api-input-param-validate-memo.html" shape="rect"><h1>如何在 spring 實作的 restful api 裡使用 validation annotation</h1></a>
        <p>2017-12-29</p>

        <p>
          <em>Tags:
            <span>
              <a shape="rect" href="tags/程式語言.html">程式語言</a>
              <span>,</span>
            </span>
            <span>
              <a shape="rect" href="tags/java.html">java</a>
              <span>,</span>
            </span>
            <span>
              <a shape="rect" href="tags/spring.html">spring</a>
              
            </span>
          </em>
        </p>

        <p><h2>如何實作</h2><p>spring 實作的 restful api，要針對輸入參數進行內容格式驗証，可分成下列儿類</p><h3>針對 @RequestBody 進行 validation</h3><p>實作程式碼重點如下</p>
<!--?prettify linenums=true?-->
<pre><code class="java">@RestController
@RequestMapping(&quot;/validateAnnotationDemo&quot;)
public class ValidateAnnotationDemoController {
    @RequestMapping(value = &quot;/validateRequestBody&quot;, produces = MediaType.APPLICATION_JSON_VALUE)
    public User validateRequestBody(@Valid @RequestBody User user){
        ...etc;
    }

    private static class User{
        @NotBlank
        private String name;
        ...etc;
    }
}
</code></pre>
<!--?prettify linenums=true?-->
<pre><code class="java">@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity handleMethodArgumentNotValidException(HttpServletRequest req, MethodArgumentNotValidException e) {
        ...etc;
    }
}
</code></pre>
<ol>
  <li>@RequestBody 前面要加上 @Valid</li>
  <li>pojo (在此例指 User class) 要加上 validation annotation (e.g. @NotBlank, @NotNull ...etc)</li>
  <li>validate fail 會丟出 MethodArgumentNotValidException，要自己寫 handler 決定哪些異常明細回傳給前端</li>
</ol><h3>針對 @RequestParam 進行 validation</h3><p>實作程式碼重點如下</p>
<!--?prettify linenums=true?-->
<pre><code class="java">@Configuration
@ComponentScan
public class WebConfig {
    @Bean
    public MethodValidationPostProcessor methodValidationPostProcessor() {
        return new MethodValidationPostProcessor();
    }
}
</code></pre>
<!--?prettify linenums=true?-->
<pre><code class="java">@Validated
@RestController
@RequestMapping(&quot;/validateAnnotationDemo&quot;)
public class ValidateAnnotationDemoController {
    @RequestMapping(value = &quot;/validateRequestParam&quot;, produces = MediaType.APPLICATION_JSON_VALUE)
    public Map&lt;String,Object&gt; validateRequestParam(@NotBlank(message = &quot;message must not be blank&quot;) @RequestParam String message){
        ...etc;
    }
}
</code></pre>
<!--?prettify linenums=true?-->
<pre><code class="java">@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity handleConstraintViolationException(HttpServletRequest req, ConstraintViolationException e){
        ...etc;
    }
}
</code></pre>
<ol>
  <li>要注冊 MethodValidationPostProcessor bean，不然無法對 @RequestParam 進行 validation</li>
  <li>在 @RestController 前面加上 @Validated</li>
  <li>在 @RequestParam 前面加上 validation annotation (e.g. @NotBlank, @NotNull ...etc)</li>
  <li>validate fail 會丟出 ConstraintViolationException，要自己寫 handler 決定哪些異常明細回傳給前端</li>
</ol><h2>完整範例</h2><h3>WebConfig.java</h3>
<!--?prettify linenums=true?-->
<pre><code class="java">@Configuration
@ComponentScan
public class WebConfig {

    /**
     * 注冊 MethodValidationPostProcessor bean 之後，Controller class 開頭加的 @Validated 與 method 裡針
     * 對 @RequestParam annotation 加的 validate annotation (e.g. @NotBlank, @NotNull ...etc)才會生效，
     * 沒注冊時就算程式碼裡有加這些 annotation 還是不會有作用
     *
     * @return
     */
    @Bean
    public MethodValidationPostProcessor methodValidationPostProcessor() {
        return new MethodValidationPostProcessor();
    }
}
</code></pre><h3>ValidateAnnotationDemoController.java</h3>
<!--?prettify linenums=true?-->
<pre><code class="java">@Validated
@RestController
@RequestMapping(&quot;/validateAnnotationDemo&quot;)
public class ValidateAnnotationDemoController {

    //在 class 開頭加了 @Validated 之後，針對 @RequestParam 加的 validation annotation (e.g. @NotBlank, @NotNull...etc) 才會生效
    @RequestMapping(value = &quot;/validateRequestParam&quot;, produces = MediaType.APPLICATION_JSON_VALUE)
    public Map&lt;String,Object&gt; validateRequestParam(
            @NotBlank(message = &quot;message must not be blank&quot;) @RequestParam String message){
        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();
        result.put(&quot;message&quot;, message);
        return result;
    }

    // 加對 @Valid 之後，會驗証 pojo (此例中指 User instance) 內容格式是否正確
    @RequestMapping(value = &quot;/validateRequestBody&quot;, produces = MediaType.APPLICATION_JSON_VALUE)
    public User validateRequestBody(@Valid @RequestBody User user){
        return user;
    }

    private static class User{
        @NotBlank
        private String name;

        // 針對 list of pojo 的資料格式進行驗証，要加上 @NotEmpty, @Valid 二個 annotation
        @NotEmpty
        @Valid
        private List&lt;ContactInfo&gt; contactInfoList;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public List&lt;ContactInfo&gt; getContactInfoList() {
            return contactInfoList;
        }

        public void setContactInfoList(List&lt;ContactInfo&gt; contactInfoList) {
            this.contactInfoList = contactInfoList;
        }
    }

    private static class ContactInfo{
        @NotBlank
        private String address;

        public String getAddress() {
            return address;
        }

        public void setAddress(String address) {
            this.address = address;
        }
    }
}
</code></pre><h3>GlobalExceptionHandler.java</h3>
<!--?prettify linenums=true?-->
<pre><code class="java">/**
 * Controller 發生 uncatch exception 情況時，會統一在這個 class 被處理。
 */
@ControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(Exception.class)
    public ResponseEntity handleException(HttpServletRequest req, Exception e){
        logger.error(e.getMessage(), e);
        String errorMsg = (e.getMessage() == null) ? e.getClass().getSimpleName() : e.getMessage();
        Map&lt;String,Object&gt; error = Collections.singletonMap(&quot;error&quot;, errorMsg);
        return ResponseEntity.status(500).body(error);
    }

    /**
     * Controller 裡標注 @RequestParam 的變數在 validate fail 時會丟出 ConstraintViolationException。這個 method
     * 專門處理此類 exception
     *
     * @param req
     * @param e
     *
     * @return
     */
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity handleConstraintViolationException(HttpServletRequest req, ConstraintViolationException e){
        logger.error(e.getMessage(), e);
        // &quot;@NotBlank @RequestParam String myArg&quot; 這樣的 validate 寫法在 validate fail 時無法得知 &quot;哪個輸入參數名稱&quot; 驗証失敗，這是 java reflection 本身的限制。
        // 用這類語法時要改寫成 &quot;@NotBlank(myArg must not be blank) @RequestParam String myArg&quot;，程式裡的 validate annotation 要寫出 &quot;完整出錯明細&quot;，
        // 不然在處理 ConstraintViolationException 時只會知道驗証失敗的原因，卻不知道是哪個輸入參數名稱驗証失敗。
        List&lt;String&gt; errorMessages = e.getConstraintViolations()
                .stream()
                .map(ConstraintViolation::getMessage)
                .collect(Collectors.toList());
        Map&lt;String,Object&gt; error = Collections.singletonMap(&quot;error&quot;, errorMessages);
        return ResponseEntity.status(400).body(error);
    }

    /**
     * Controller 裡標注 @RequestBody 的變數在 validate fail 時會丟出 MethodArgumentNotValidException。這個 method
     * 專門處理此類 exception
     *
     * @param req
     * @param e
     *
     * @return
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity handleMethodArgumentNotValidException(HttpServletRequest req, MethodArgumentNotValidException e) {
        logger.error(e.getMessage(), e);
        List&lt;String&gt; errorMessages = e.getBindingResult().getFieldErrors()
                .stream()
                .map(fieldError -&gt; fieldError.getField() + &quot; &quot; + fieldError.getDefaultMessage()) // 記錄 &quot;fieldName + validateFailMessage&quot;
                .collect(Collectors.toList());
        Map&lt;String,Object&gt; error = Collections.singletonMap(&quot;error&quot;, errorMessages);
        return ResponseEntity.status(400).body(error);
    }
}
</code></pre><h2>reference document</h2>
<ul>
  <li><a href="https://www.jianshu.com/p/51e8d2702ca1">在Spring MVC中使用註解的方式校驗RequestParams</a></li>
  <li><a href="https://sdqali.in/blog/2015/12/04/validating-requestparams-and-pathvariables-in-spring-mvc/">Validating RequestParams and PathVariables in Spring MVC</a></li>
  <li><a href="https://stackoverflow.com/a/38615327/8646444">Spring Boot REST @RequestParam not being Validated</a></li>
  <li><a href="https://stackoverflow.com/a/35588953/8646444">Spring MVC - @Valid on list of beans in REST service</a></li>
</ul></p>

        <hr />
      </div>

      <div>
        <a href="blog/2016/02/mac-memo-for-beginner.html" shape="rect"><h1>MAC 新手入門筆記</h1></a>
        <p>2016-03-04</p>

        <p>
          <em>Tags:
            <span>
              <a shape="rect" href="tags/mac.html">mac</a>
              
            </span>
          </em>
        </p>

        <p><p>儿個月前因為工作需要摸了一陣子 MAC 筆電，有一些簡單心得，所以做個筆記以備未來不時之需 :)</p><h2>MAC OS 入門影片</h2>
<ol>
  <li>英文
  <ul>
    <li><a href="https://www.youtube.com/watch?v=wSPisJXyjso">Learn the MAC In Under 90 Minutes 2015 Yosemite Edition</a></li>
    <li><a href="https://www.youtube.com/watch?v=kgS6E-6vStA">El Capitan OS X Tutorial</a></li>
  </ul></li>
  <li>中文
  <ul>
    <li><a href="https://www.youtube.com/playlist?list=PLtDm33ESx3munKRdCXwvw4Bge2k2b-RZh">Mac OS X 基礎教學</a></li>
    <li><a href="https://www.youtube.com/playlist?list=PL7A481B6116A5B721">Mac 相關教學</a></li>
  </ul></li>
</ol><h2>MAC OS 入門文件</h2>
<ul>
  <li><a href="http://appleuser.com/mac-os-x-teach-all/">Mac 新手教學區</a></li>
  <li><a href="http://mac-osx-for-newbie-book.kejyun.com/">Mac OSX 新手入門</a></li>
  <li><a href="http://www.playpcesor.com/2014/01/mac-macbook-air.html">[Mac 新手日記] 讓 Macbook Air 靈活百倍的觸控板手勢教學</a></li>
  <li><a href="http://www.playpcesor.com/2015/04/mac-10-finder.html">Mac 用戶一定要知道這10個 Finder 獨特檔案整理技巧</a></li>
  <li><a href="http://www.playpcesor.com/2014/01/mac-apple-mac-os-x.html">[Mac 新手日記] Apple Mac OS X 截圖文書必備快捷鍵教學</a></li>
  <li><a href="http://www.playpcesor.com/2015/05/Mac-preview-photo-pdf-editor.html">Mac 用戶不可不用預覽程式：13招取代修圖 PDF 軟體</a></li>
  <li><a href="http://www.playpcesor.com/2015/04/mac-photos-app-14.html">Mac 全新內建 Photos 照片 App 你一定要會的14件事</a></li>
  <li><a href="http://www.playpcesor.com/2014/03/mac-quicktime-player.html">[Mac 新手日記] QuickTime Player 螢幕錄影與影片剪輯教學</a></li>
</ul><h2>SSH 相關 console command</h2>
<ol>
  <li><p>產生 SSH 公私鑰</p>
  <!--?prettify?-->
  <pre><code>ssh-keygen -t rsa
</code></pre></li>
  <li><p>Storing Passphrases in the Keychain, 免除每次 ssh 連線都要指定 private key 所在位置</p>
  <!--?prettify?-->
  <pre><code>ssh-add -K /path/to/private/key/file
</code></pre></li>
  <li><p>相關參考文件</p>
  <ul>
    <li><a href="http://blog.longwin.com.tw/2005/12/ssh_keygen_no_passwd/">http://blog.longwin.com.tw/2005/12/ssh_keygen_no_passwd/</a></li>
    <li><a href="https://ekkescorner.wordpress.com/blog-series/git-mercurial/step-by-step-ssh-on-osx-ubuntu-and-windows/">https://ekkescorner.wordpress.com/blog-series/git-mercurial/step-by-step-ssh-on-osx-ubuntu-and-windows/</a></li>
    <li><a href="http://stackoverflow.com/a/11673152">http://stackoverflow.com/a/11673152</a></li>
  </ul></li>
</ol><h2>利用 homebrew 指令安裝軟體</h2><p>homebrew 可以幫你用 <code>console command</code> 的方式安裝與管理各種軟體，可以讓你在這方面省掉很多時間，強烈推薦要用這個好物。下面列的是我常會利用 homebrew 安裝的軟體。</p>
<!--?prettify?-->
<pre><code># install xcode command tool
xcode-select --install
# check xcode command tool
xcode-select -p

# install homebrew
ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
# check homebrew install success or not
brew doctor
brew update

# install homebrew-cask
brew tap caskroom/cask
brew install brew-cask

# i install these soft below by brew &amp; brew-cask

brew install wget
brew install curl
brew install git
brew install htop-osx

# install java7
brew cask install caskroom/versions/java7
# install java8
brew cask install java

brew cask install intellij-idea-ce
brew cask install eclipse-jee

brew install maven
brew install gradle

brew cask install sourcetree
brew cask install cyberduck
brew cask install dbeaver-enterprise

brew cask install google-chrome
brew cask install firefox
brew cask install flash

brew cask install bettertouchtool
</code></pre><h2>其它實用的教學文件</h2>
<ul>
  <li><a href="http://aimijia.net/2014/05/each-mac-os-x-command-line-users-should-be-aware-of-the-eight-terminal-tool/">【譯】每個Mac OS X 命令行用戶應當知道的八個終端工具</a></li>
</ul></p>

        <hr />
      </div>

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <p>較舊的文章在
      <a href="archive.html" shape="rect">archive</a> 專區.</p>
    </div>
  </div>

  <div>
      <div id="push"></div>

        <div id="footer">
          <div class="container">
            <p class="muted credit">&copy; <span>2021</span> CloudTu | Baked with <a href="http://jbake.org" shape="rect">JBake
              <span>v2.3.2</span></a></p>
          </div>
        </div>

        <!-- Le javascript
        ================================================== -->
        <!-- Placed at the end of the document so the pages load faster -->
        <script xml:space="preserve" src="/js/jquery-2.1.1.min.js"></script>
        <script xml:space="preserve" src="/js/bootstrap.min.js"></script>
        <script xml:space="preserve" src="/js/prettify.js"></script>

      </div>
    </body>
</html>
